<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈设计模式]]></title>
    <url>%2F2019%2F05%2F22%2F%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式分类总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： 设计模式六大原则总原则：开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1、单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 Java的设计模式顺序根据Head First Design Patterns 一、策略模式定义 策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立。 特点 策略模式体现了面向对象程序设计中非常重要的两个原则： 1. 封装变化的概念。 2. 编程中使用接口，而不是使用的是具体的实现类(面向接口编程)。 举例 我们就以Java中的TreeSet为例，TreeSet仅仅知道它只是接收一个Comparator这种接口类型，但是具体是哪种实现类，TreeSet并不关心，实现类在真正的传入TreeSet之前，TreeSet本身是不知道的，所以我们可以自己去实现Comparator接口，然后在实现类里面去封装好我们自己的规则（这里的规则你可以当做是算法），比如说我们要实现对一个集合的元素排序，但是到底是要升序排序还是降序排序，这个完全由我们来去控制，我们可以把这种变化的内容封装到自己的实现类中，真正运行的时候才知道具体的实现。 组成 抽象策略角色这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。 具体策略角色包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。 环境角色内部会持有一个抽象角色的引用，给客户端调用。对比来说，就是我们的TreeSet类。说明：TreeSet内部一定会有一个策略类的一个成员变量，这样做的目的在于可以当我们在去创建TreeSet对象的时候，可以接收我们向TreeSet类中传递的具体的策略类。编写步骤 定义抽象策略角色(为策略对象定义一个公共的接口) 编写具体策略角色(实际上就是实现上面定义的公共接口) 定义环境角色，内部持有一个策略类的引用案例实现一个加减乘除的功能。 定义抽象策略角色 /* 定义抽象策略角色 * 类似于Comparator接口 */ public interface Strategy{ /* * 实现了两个数可以计算 */ public int calc(int num1,int num2); } 定义具体策略角色(本例子仅仅演示，只是定义加、减两种具体策略) /* * 定义加法策略 */ public class AddStrategy implements Strategy{ /* * 实现clac方法，完成两个数的和 */ public int calc(int num1,int num2){ return num1+num2; } } /* * 定义减法策略 */ public class SubtractStrategy implements Strategy{ /* * 实现clac方法，完成两个数相减 */ public int calc(int num1,int num2){ return num1-num2; } } 环境角色 /* 环境角色 类似于TreeSet*/public class Environment{// 持有对策略类的引用private Strategy strategy; // 类似于TreeSetpublic Environment(Strategy strategy){this.strategy = strategy;} public int calulate(int a , int b){return strategy.calc(a,b);}} 测试类 /* * 测试类 */ public class Test{ public static void main(String[] args){ Environment environment = new Environment(new AddStrategy()); int result = environment.calulate(20,30); Ststem.out.println(result); } } 总结策略模式的优点： 策略模式的功能就是通过抽象、封装来定义一系列的算法，使得这些算法可以相互替换，所以为这些算法定义一个公共的接口，以约束这些算法的功能实现。如果这些算法具有公共的功能，可以将接口变为抽象类，将公共功能放到抽象父类里面。 策略模式的一系列算法是可以相互替换的、是平等的，写在一起就是if-else组织结构，如果算法实现里又有条件语句，就构成了多重条件语句，可以用策略模式，避免这样的多重条件语句。 扩展性更好：在策略模式中扩展策略实现非常的容易，只要新增一个策略实现类，然后在使用策略实现的地方，使用这个新的策略实现就好了。 策略模式的缺点： 客户端必须了解所有的策略，清楚它们的不同：如果由客户端来决定使用何种算法，那客户端必须知道所有的策略，清楚各个策略的功能和不同，这样才能做出正确的选择，但是这暴露了策略的具体实现。 增加了对象的数量：由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多。 只适合偏平的算法结构：由于策略模式的各个策略实现是平等的关系（可相互替换），实际上就构成了一个扁平的算法结构。即一个策略接口下面有多个平等的策略实现（多个策略实现是兄弟关系），并且运行时只能有一个算法被使用。这就限制了算法的使用层级，且不能被嵌套。 参考自 策略模式详解、深入解析策略模式 二、观察者（Observer）模式定义在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 大白话其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 结构图 组成 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。使用场景例子有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。具体实现 定义一个抽象被观察者接口 /*** 抽象被观察者接口 声明了添加、删除、通知观察者方法 @author charming /public interface Observerable { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver(); } 定义一个抽象观察者接口 /*** 抽象观察者 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 @author charming /public interface Observer { public void update(String message);} 定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。 import java.util.ArrayList;import java.util.List; /** 被观察者，也就是微信公众号服务 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 @author charming /public class WechatServer implements Observerable { //注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程private List list;private String message; public WechatServer() { list = new ArrayList();} @Overridepublic void registerObserver(Observer o) { list.add(o);} @Overridepublic void removeObserver(Observer o) { if(!list.isEmpty()) list.remove(o); } //遍历@Overridepublic void notifyObserver() { for(int i = 0; i &lt; list.size(); i++) { Observer oserver = list.get(i); oserver.update(message); }} public void setInfomation(String s) { this.message = s; System.out.println(&quot;微信服务更新消息： &quot; + s); //消息更新，通知所有观察者 notifyObserver(); } } 定义具体观察者，微信公众号的具体观察者为用户User /** 观察者 实现了update方法 @author charming /public class User implements Observer { private String name; private String message; public User(String name) { this.name = name; } @Override public void update(String message) { this.message = message; read(); } public void read() { System.out.println(name + &quot; 收到推送消息： &quot; + message); }} 编写一个测试类 首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。 用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户还是正常能收到推送消息。 public class Test { public static void main(String[] args) { WechatServer server = new WechatServer(); Observer userZhang = new User(&quot;ZhangSan&quot;); Observer userLi = new User(&quot;LiSi&quot;); Observer userWang = new User(&quot;WangWu&quot;); server.registerObserver(userZhang); server.registerObserver(userLi); server.registerObserver(userWang); server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;); System.out.println(&quot;----------------------------------------------&quot;); server.removeObserver(userZhang); server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;); } } 测试结果 小结 这个模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影像。 JDK中也有自带的观察者模式。但是被观察者是一个类而不是接口，限制了它的复用能力。 在JavaBean和Swing中也可以看到观察者模式的影子。 三、装饰者模式12&gt; 很烦，装饰者模式没保存到，由于篇幅过长我就不再贴了，放到后面与代理模式比较吧。&gt; ##四、 工厂模式 概念 为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 类别 简单工厂模式Simple Factory：不利于产生系列产品； 工厂方法模式Factory Method：又称为多形性工厂； 抽象工厂模式Abstract Factory：又称为工具箱，产生产品族，但不利于产生新的产品； 这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 1. 简单工厂模式简单工厂模式又称静态工厂方法模式。从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。在简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定哪一个产品类应当被实例化。 先来看看它的组成： 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 简单工厂模式又分为三种： 普通:就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口： public interface Sender { public void Send(); } 其次，创建实现类： public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 最后，建工厂类： public class SendFactory { public Sender produce(String type) { if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 我们来测试下： public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produce(&quot;sms&quot;); sender.Send(); } } 输出：this is sms sender! 多个方法是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：将上面的代码做下修改，改动下SendFactory类就行，如下： public class SendFactory { public Sender produceMail(){ return new MailSender(); } public Sender produceSms(){ return new SmsSender(); } } 测试类如下： public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); } } 输出：this is mailsender! 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 public class SendFactory { public static Sender produceMail(){ return new MailSender(); } public static Sender produceSms(){ return new SmsSender(); } } public class FactoryTest { public static void main(String[] args) { Sender sender = SendFactory.produceMail(); sender.Send(); } } 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2. 工厂方法模式（Factory Method） 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 public interface Sender { public void Send(); } //两个实现类： public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } //工厂接口 public interface Provider { public Sender produce(); } //两个工厂类： public class SendMailFactory implements Provider { @Override public Sender produce(){ return new MailSender(); } } public class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } //测试类： public class Test { public static void main(String[] args) { Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); } } 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 3. 抽象工厂模式 为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体实现类。 例如：Q3和Q7有不同的轮胎、发动机、制动系统。虽然生产的零件不同，型号不同。但是根本上都有共同的约束，就是轮胎、发动机、制动系统。设计如下： 1. 需要一个抽象工厂，里面有三个接口分别为生产轮胎、发动机、制动系统，抽象类 2. 需要三个抽象产品分别为轮胎、发动机、制动系统，抽象接口 3. 需要实现上面的三个抽象接口，定义出每个接口不通的对象，比如：普通轮胎和越野轮胎 4. 需要两个具体类继承自上面的抽象类，实现具体的工厂，比如：生产Q3的工厂和生产Q7的工厂 5. 在客户端new出对应的具体工厂并调用对应的生产方法 //1.抽象工厂 public abstract class CarFactory { /** * 生产轮胎 * * @return 轮胎 * */ public abstract ITire createTire(); /** * 生产发动机 * * @return 发动机 * */ public abstract IEngine createEngine(); /** * 生产制动系统 * * @return 制动系统 * */ public abstract IBrake createBrake(); } //2.三个产品抽象接口 public interface ITire { /** * 轮胎 */ void tire(); } public interface IEngine { /** *发动机 */ void engine(); } public interface IBrake { /** *制动系统 */ void brake(); } //3.根据抽象接口定义不同的对象 public class NormalBrake implements IBrake{ @Override public void brake() { System.out.println(&quot;普通制动&quot;); } } public class SeniorBrake implements IBrake{ @Override public void brake() { System.out.println(&quot;高级制动&quot;); } } //后面的定义省略。。。。。。。。。。。。。 //4.实现具体的工厂类 public class Q3Factory extends CarFactory{ @Override public ITire createTire() { return new NormalTire(); } @Override public IEngine createEngine() { return new DomesticEngine(); } @Override public IBrake createBrake() { return new NormalBrake(); } } //5.客户端使用 public class Client { public static void main(String[] args) { //A车厂 CarFactory factoryQ3 = new Q3Factory(); factoryQ3.createTire().tire(); factoryQ3.createEngine().engine(); factoryQ3.createBrake().brake(); } } //输出 普通轮胎 国产发动机 普通制动 4. 工厂方法模式和抽象工厂模式区别 工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 对于java来说，你能见到的大部分抽象工厂模式都是这样的：—它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。 比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。 这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法； 用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法） 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线 五、单例模式定义 单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 好处 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 基本的实现思路 单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。 单例的实现主要是通过以下两个步骤： 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 注意事项 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 单例模式的八种写法1、饿汉式（静态常量）[可用] public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } } 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 2、饿汉式（静态代码块）[可用]public class Singleton { private static Singleton instance; static { instance = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return instance; } } 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 ####3、懒汉式(线程不安全)[不可用] public class Singleton { private static Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。 ####4、懒汉式(线程安全，同步方法)[不推荐用] public class Singleton { private static Singleton singleton; private Singleton() {} public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 ####5、懒汉式(线程安全，同步代码块)[不可用] public class Singleton { private static Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } 由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 ####6、双重检查[推荐用] public class Singleton { private static volatile Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。 优点：线程安全；延迟加载；效率较高。 ####7、静态内部类[推荐用] public class Singleton { private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } } 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 ####8、枚举[推荐用] public enum Singleton { INSTANCE; public void whateverMethod() { } } 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。 总结 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。 最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。 参考自单例模式的八种写法比较 ##六、命令模式 定义 命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. 举例 假设某个公司需要设计一个多用功能的遥控器。基本的需求如下： 该遥控器有可以控制风扇，白炽灯，热水器等等的多对开关，而且可能还有其他的电器，暂时不做其功能，但是希望可以保留接口，用的时间可以方便的扩展。 除上面的需求之外，还需要有个按钮，可以撤销上一步的操作。基本功能如下图：在设计遥控器时，风扇，白炽灯，热水器的开关方法已经定义好，其名字各不相同。不妨设置其方法为如下： 由于各种电器的开关方法都不一样，而且还存在一个待扩展的电器，如果没有学习命名模式之前，我们在设置扩展的开关时，会出现的问题是什么呢？假设现在有电视，冰箱还可能会用到遥控器，那么我们会在最后一个开关上写if else，当然如果哪一天有多了一个大门也加入了我们的遥控的行列，这样我们继续加if else ，很显然随着电器的高速发展，会有多个需要遥控可以控制的。 举个例子，如果我们是需要遥控的客户，现在有一款遥控如果有遥控可以进行扩展，一种是可以扩展指定类型的，像上面的，只能再去扩展电视和冰箱中的一种，偶尔有一天你看到隔壁邻居的门，也可以使用遥控了，所以你去把你的高级遥控器，拿到扩展店时，扩展工程师说了，现在只能扩展电视和冰箱，不支持对大门的遥控扩展. 我们肯定是希望，可以自由的扩展，大门可以使用遥控了，就对大门扩展，车门使用遥控了，就对车门扩展……其实也就是一种松耦合的实现。 我们可以先定义好我们的风扇，白炽灯，热水器。然后定义其分别的开关命令，每个命令都有自己对应的电器引用，而且会在命令的Excute中包装电器的开或者关，最后需要把命令安装到遥控器上面，在遥控器上每个按钮都对应有自己的激发方法，其代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201namespace RemoteControl&#123; class Program &#123; static void Main(string[] args) &#123; //家中的电器 Fan fan=new Fan(); Light light=new Light(); Heater heater=new Heater(); //电器分别对应的命令 FanOffCommand fanOffCommand=new FanOffCommand(fan); FanOnCommand fanOnCommand=new FanOnCommand(fan); LightOnCommand lightOnCommand=new LightOnCommand(light); LightOffCommand lightOffCommand=new LightOffCommand(light); HeaterOnCommand heaterOnCommand=new HeaterOnCommand(heater); HeaterOffCommand heaterOffCommand=new HeaterOffCommand(heater); RemoteControl remoteControl = new RemoteControl(); //设置遥控器 remoteControl.SetCommand(0, fanOnCommand, fanOffCommand); remoteControl.SetCommand(1, lightOnCommand, lightOffCommand); remoteControl.SetCommand(2, heaterOnCommand, heaterOffCommand); //分别测试遥控器的命令 remoteControl.OnButtonWasPress(1); remoteControl.OffButtonWasPress(1); remoteControl.OnButtonWasPress(0); remoteControl.OffButtonWasPress(0); Console.ReadKey(); &#125; &#125; /// &lt;summary&gt; /// 风扇类 /// &lt;/summary&gt; public class Fan &#123; public void FanOn() &#123; Console.WriteLine(&quot;风扇开了&quot;); &#125; public void FanOff() &#123; Console.WriteLine(&quot;风扇关了&quot;); &#125; &#125; /// &lt;summary&gt; /// 灯类 /// &lt;/summary&gt; public class Light &#123; public void LightOn() &#123; Console.WriteLine(&quot;灯亮了&quot;); &#125; public void LightOff() &#123; Console.WriteLine(&quot;灯灭了&quot;); &#125; &#125; /// &lt;summary&gt; /// 热水器类 /// &lt;/summary&gt; public class Heater &#123; public void HeaterOn() &#123; Console.WriteLine(&quot;加热中&quot;); &#125; public void HeaterOff() &#123; Console.WriteLine(&quot;停止加热&quot;); &#125; &#125; /// &lt;summary&gt; /// 命令接口 /// &lt;/summary&gt; public interface ICommand &#123; void Excute(); &#125; public class FanOnCommand : ICommand &#123; Fan fan; public FanOnCommand(Fan fan) &#123; this.fan = fan; &#125; public void Excute() &#123; this.fan.FanOn(); &#125; &#125; public class FanOffCommand : ICommand &#123; Fan fan; public FanOffCommand(Fan fan) &#123; this.fan = fan; &#125; public void Excute() &#123; this.fan.FanOff(); &#125; &#125; public class LightOnCommand : ICommand &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; light.LightOn(); &#125; &#125; public class LightOffCommand : ICommand &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; this.light.LightOff(); &#125; &#125; public class HeaterOnCommand : ICommand &#123; Heater heater; public HeaterOnCommand(Heater heater) &#123; this.heater = heater; &#125; public void Excute() &#123; this.heater.HeaterOn(); &#125; &#125; public class HeaterOffCommand : ICommand &#123; Heater heater; public HeaterOffCommand(Heater heater) &#123; this.heater = heater; &#125; public void Excute() &#123; this.heater.HeaterOff(); &#125; &#125; public class NoCommand : ICommand &#123; public void Excute() &#123; &#125; &#125; public class RemoteControl &#123; private ICommand[] onCommands; private ICommand[] offCommands; public RemoteControl() &#123; ICommand noCommand=new NoCommand(); onCommands = new ICommand[4]; offCommands = new ICommand[4]; for (int i = 0; i &lt; 4; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand; &#125; &#125; public void SetCommand(int slot, ICommand onCommand, ICommand offCommand) &#123; onCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void OnButtonWasPress(int slot) &#123; onCommands[slot].Excute(); &#125; public void OffButtonWasPress(int slot) &#123; offCommands[slot].Excute(); &#125; &#125;&#125; 这样基本上就实现了我们的现有的三种电器的遥控。需要注意的是，在开始初始化遥控器时，对每个命令初始化成了NoCommand，也就是什么都不执行。在命令的初始化经常使用，同时这也解决了我们的在扩展前什么都不做的难题。看了风扇，白炽灯，热水器的遥控实现，进一步的扩展任何的电器，相信都不是什么难事。但是还有个功能没有实现，就是撤销到上一步的操作，接下来我们就来实现撤销操作。 撤销操作就想我们遥控中的返回一样。基本上就是灯亮着，突然按了一下关灯，然后再按一下返回键，灯就亮了。其他的电器同样的道理。下面先看一下灯的撤销原理，命令除了执行外还有一个撤销，所以我们需要先都命令的接口添加一个方法。 123456789101112131415161718192021222324252627282930/// &lt;summary&gt; /// 命令接口 /// &lt;/summary&gt; public interface ICommand &#123; void Excute(); void Undo(); &#125;对于开灯需要做的修改如下：public class LightOnCommand : ICommand &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; light.LightOn(); &#125; /// &lt;summary&gt; /// 调用命令的反命令 /// &lt;/summary&gt; public void Undo() &#123; light.LightOff(); &#125; &#125; 其他命令同理，代码会在源码中一并给出。也就是每个命令都有自己的反命令，在Undo方法里面也就是调用反命令的Excute方法。每当按下一个按钮时，就去记录其命令的名称，如果按撤销的话，就执行命名的Undo方法。下面给出主要代码：1234567891011121314public void OnButtonWasPressed(int slot) &#123; onCommands[slot].Excute(); backCommand=onCommands[slot]; &#125; public void OffButtonWasPressed(int slot) &#123; offCommands[slot].Excute(); backCommand = offCommands[slot]; &#125; public void BackButtonWasPressed() &#123; backCommand.Undo(); &#125; 以上是对遥控器对命令的撤销，需要注意两点1、通过记住命令执行之前的状态，然后去恢复到原来的状态。2、在每次执行之后要记住执行的那个命令。也即记住命令和记住状态。 除了一次执行一个命令和撤销一个命令，当然还可以一次执行多个命令。下面给出主要代码：1234567891011121314151617181920212223242526272829public class MutlipleCommand : ICommand &#123; ICommand[] commands; ICommand[] backCommands; public MutlipleCommand(ICommand[] commands) &#123; this.commands = commands; backCommands = new ICommand[commands.Length]; &#125; public void Excute() &#123; for (int i = 0; i &lt; commands.Length; i++) &#123; commands[i].Excute(); backCommands[i] = commands[i]; &#125; &#125; public void Undo() &#123; for (int i = 0; i &lt; commands.Length; i++) &#123; backCommands[i].Undo(); &#125; &#125; &#125; 总结 命令模式主要通过中介Command实现了发出命令者和命令的执行者，也即Invoke类和Receiver的松耦合。 参考自命令模式 七、适配器模式定义 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 ###1、类的适配器模式 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：1234567891011121314151617181920212223242526272829303132333435363738394041public class Source &#123; public void method1() &#123; System.out.println(&quot;this is original method!&quot;); &#125; &#125;public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(&quot;this is the targetable method!&quot;); &#125; &#125;//Adapter类继承Source类，实现Targetable接口，下面是测试类：public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125;输出：this is original method!this is the targetable method!这样Targetable接口的实现类就具有了Source类的功能。 ###2、对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图： 只需要修改Adapter类的源码即可：1234567891011121314151617181920212223242526272829public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(&quot;this is the targetable method!&quot;); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125;输出与第一种一样，只是适配的方法不同而已。 ###3、接口的适配器模式 第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：123456789101112131415161718192021222324252627282930313233343536public interface Sourceable &#123; public void method1(); public void method2(); &#125;public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; ; public void method2()&#123;&#125; ;&#125;public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); &#125; &#125;public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); &#125; &#125;public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出： the sourceable interface’s first Sub1!the sourceable interface’s second Sub2! 达到了我们的效果！ 总结 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 八、模板方法模式（略） 九、迭代器与组合模式（略） 十、状态模式（略） 十一、代理模式（极其重要）与装饰者模式的区别 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 举个例子 例如：有婴儿，婴儿会吃饭和走动，如以下类1234567891011121314//婴儿类public class Child implements Human&#123; public void eat() &#123; System.out.println(&quot;eat something....&quot;); &#125; @Override public void run() &#123; System.out.println(&quot;Child run very slow&quot;); &#125;&#125; 突然有一天，家长发现不行，孩子不能随便吃东西，而且吃饭前一定要洗手。但是孩子太小(被委托方)，不会自己洗手。家长(Client 端)又没法照顾孩子。那简单，找个保姆照顾孩子！ 让保姆类和婴儿类共同实现同一个接口，让保姆类全程管理小孩，同时在家长眼里，只要看到保姆在帮孩子洗手就可以了。于是，有以下内容。1234567891011121314151617//保姆类public class BabySitter implements Human&#123; @Override public void eat() &#123; &#125; @Override public void run() &#123; &#125;&#125; 现在保姆已经有了，孩子也有了，怎么把孩子跟保姆关联起来。让保姆给相应的孩纸洗手。于是保姆类更改如下12345678910111213141516171819202122232425262728293031//保姆类public class BabySitter implements Human&#123; private Human human; public BabySitter(Human human) &#123; this.human = human; &#125; @Override public void eat() &#123; // 添加washHand的方法 this.washHandForChild(); human.eat(); &#125; @Override public void run() &#123; &#125; public void washHandForChild() &#123; System.out.println(&quot;help the child to wash his hands&quot;); &#125;&#125;保姆与婴儿类关联 好，那么家长就是给孩纸找了个保姆助手(装饰器)，让他附加了一些婴儿做不了事。同时家长也没有强迫孩纸自己学会洗手(不更改Child类)1234567891011//客户端public class Client&#123; public static void main(String[] args) &#123; Human human = new BabySitter(new Child()); human.eat(); &#125;&#125;家长客户端代码 以上就是一个简单的装饰模式，来看一下这一块完整的类图。 装饰模式的一个很重要特点就是，在客户端可以看到抽象对象的实例，如Human human = new BabySitter(new Child()); 因为装饰模式通过聚合方式，把内容整合到装饰类里面了。 装饰者模式能够使用装饰类对抽象对象进行装饰。假如来了个OldMan类手脚不利索。保姆类BabySitter同样能够胜任这个OldMan的饭前洗手操作。 代理模式类图如下： 由该类图可知，以上BabySitter代码应该如下：123456789101112131415161718192021222324252627282930313233343536373839//保姆类public class BabySitter implements Human&#123; private Child child; public BabySitter() &#123; child = new Child(); &#125; @Override public void eat() &#123; // 添加washHand的方法 this.washHandForChild(); human.eat(); &#125; @Override public void run() &#123; &#125; public void washHandForChild() &#123; System.out.println(&quot;help the child to wash his hands&quot;); &#125;&#125;//客户端public class Client&#123; public static void main(String[] args) &#123; Human human = new BabySitter(); human.eat(); &#125;&#125; 装饰者模式和代理模式的最后运行的结果都是一样的，由代理模式代码可知，客户端不关心代理类了哪个类。但代码控制了客户端对委托类的访问。客户端代码表现为 Human human = new BabySitter( ); 所以资料上都说了，装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制。两者都一样拥有抽象角色（接口）、真实角色（委托类）、代理类 。 由于代理类实现了抽象角色的接口，导致代理类无法通用。如有天，一个有钱人养了只小猩猩，他要一个保姆在猩猩吃东西前，帮猩猩洗手….保姆根本不懂猩猩的特性（跟猩猩类不是同一类型的，保姆属于Human类，而猩猩可能属于Animal类型。），但洗手这个方法是不变的，用水洗。能不能找一个代理说既可以照看人吃饭前洗手也可以照看猩猩吃饭前洗手？ 要实现这种功能，必须让代理类与特定的接口分离。在代理的时候能够了解每个委托的特性，这就有可能了。这时候动态代理就出现了。 动态代理关于动态代理模式里面有两种实现，一种是jdk实现，一种是cglib来实现。下面来整jdk来实现动态代理的Java实例。jdk动态代理模式里面有个拦截器的概念，在jdk中，只要实现了InvocationHandler这个接口的类就是一个拦截器类。还使用了些反射的相关概念。拦截器的概念不了解没关系，假如写了个请求到action，经过拦截器，然后才会到action。然后继续有之后的操作。拦截器就像一个过滤网，一层层的过滤，只要满足一定条件，才能继续向后执行。拦截器的作用：控制目标对象的目标方法的执行。 拦截器的具体操作步骤：1.引入类：目标类和一些扩展方法相关的类。2.赋值：调用构造函数给相关对象赋值3.合并逻辑处理：在invoke方法中把所有的逻辑结合在一起。最终决定目标方法是否被调用。 总结 动态代理静态代理的区别，代理涉及到两个关联词代理类和委托类。静态代理一个代理类针对一个委托类！动态代理一个代理类可利用反射机制代理多个委托类 我们根据加载被代理类的时机不同，将代理分为静态代理和动态代理。如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，比如RPC框架和Spring AOP机制。 参考自代理模式和装饰模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十三)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下UDP和TCP的对比. UDP和TCP在TCP/IP体系中的位置 UDP和TCP的对比 UDP和TCP的对比–是否面向连接 UDP和TCP的对比–是否支持广播和多播 UDP和TCP的对比–对应用层报文的处理 UDP和TCP的对比–是否提供可靠传输服务 UDP和TCP的对比–首部开销 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十二)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下TCP/IP体系运输层的端口号. 运输层协议和网际层协议的作用范围 从体系结构的角度看进程之间的通信 基于端口的复用和分用 TCP/IP运输层端口号 举点端口号的例子 常用的熟知端口(了解) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十一)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下网际控制报文协议ICMP,仅记忆几张图即可. 网际控制报文协议ICMP 四种常见的ICMP差错报告报文 两种ICMP询问报文 ICMP的应用举例 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下IPv4数据报的首部. 数据包的逐层封装 接下来的内容涵盖在IP首部中 IPv4数据报首部格式 版本 首部长度 区分服务 总长度 讲到首部长度和总长度我们来看一个例子吧,Tips:首部长度以4字节为单位 由于IPv4数据报长度有限,有时需要分片，这时就需要标识,标志，片偏移字段了 标识 (不同主机可能发送的标识相同,需结合源IP地址加以区分) 片偏移 标志 IPv4数据报分片举例 生存时间 协议 首部校验和 源IP地址和目的IP地址 可选字段(长度可变) 填充 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(九)]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦这一篇是硬骨头!!! 本小章整合了挺多内容,包括了路由信息协议RIP,开放最短路径优先OSPF,边界网关协议BGP. 路由选择协议–概述 静态路由选择和动态路由选择 静态路由选择 由人工配置的特定主机路由,网络路由,默认路由,黑洞路由等都属于静态路由. 这种人工配置方式简单,开销小.但不能及时适应网络状态(流量,拓扑等)的变化. 一般只在小规模网络中采用. 动态路由选择 路由器通过路由选择协议自动获取路由信息. 比较复杂,开销比较大.能较好地适应网络状态的变化. 适用于大规模网络. 互联网所采用的路由选择协议的特点 自适应动态路由选择,能较好地适应网络状态的变化 分布式路由器之间交换路由信息 分层次将整个互联网划分为许多较小的自治系统AS(autonomous system) 互联网所采用的分层次的路由选择协议 常见的路由选择协议 路由器的结构 路由选择协议–路由信息协议RIP 路由信息协议RIP(Routing Information Protocol)是最早得到广泛使用的内部网关协议IGP. RIP是一种基于距离矢量D-V(Distance-Vector)算法的协议,它使用跳数(Hop Count)作为度量(Metric)来衡量到达目的网络的距离. 默认情况下,路由器到与它直接相连网络的跳数为0,因此距离为0. 路由器到与它非直连网络的距离等于中间所经过路由器的数量. 举例的取值范围是0~15,等于或大于16的距离被定义为无穷大,即目的网络不可达. RIP认为到达目的网络距离最小的路由才是好路由 等价负载均衡 思科Cisco早期的RIP支持最大6条等价负载均衡(默认支持4条) RIP的基本工作原理 更新定时器:30s 失效定时器:180s 清除定时器:240s RIP的路由条目更新规则举个例子 RIP减少路由环路产生以及加快收敛速度的方法 RIP无法完全避免路由环路因为某路由器连接的一网络故障后,则把该条目距离写成16,并向邻居路由器发送RIP更新,而某邻居路由器可能丢包. 路由选择协议–开放最短路径优先OSPF 链路状态 邻居关系的建立和维护 链路状态通告LSA(Link State Advertisement) 链路状态更新LSU(Link State Update) 链路状态数据库LSDB(Link State DataBase) 基于LSDB进行SPF计算 OSPF的五种分组类型及其作用 多路访问网络中路由器邻居关系的建立 OSPF划分为两种不同的区域 OSPF与RIP的对比 路由选择协议–边际网关协议BGP IGP与EGP对比 BGP根据策略寻找较好的路由(不兜圈子) BGP适用于多级结构的互联网 BGP-4的四种报文 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(八)]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下默认路由和特定主机路由以及静态路由的路由环路问题. 默认路由和特定主机路由 特定主机路由,网络路由,默认路由 若有多条路由记录匹配,则”最长前缀匹配”,这样的路由更具体(也可认为更精确) 静态路由的路由环路问题 配置错误 聚合了不存在的网络 网络故障 配置错误导致路由环路由于路由表中有些条目手工添加,添加错误可能出现环路. 为了避免上述情况发生时IP数据报永无休止地转发下去, IP数据报首部有TTL生存字段,最大值为255,当路由器接收 数据报后将TTL减一,若TTL等于0则丢弃 聚合了不存在的网络而导致路由环路 上面可以解释为: 在路由表中由192.168.1.0/24和192.168.2.0/24聚合成一个网络192.168.0.0/22， 而192.168.0.0/22又包含了不存在的192.168.3.0/24和192.168.0.0/24, 若主机发送数据报给不存在的网络,路由器找不到路由记录时会走默认路由,而默认路由恰好 往回走则会出现环路问题. 解决方法:为不存在的网络地址添加黑洞路由,下一跳为null0 网络故障导致路由环路 这个也很好理解,主机发送给目的主机之间某条链路故障,路由表抹去了记录,路由器找不到记录只能走默认路由,和上述一样. (也可以添加对应的黑洞路由,当记录被抹去,则黑洞路由条目自动生效) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转发和重定向的区别]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[转发和重定向区别详解作为一名程序员，特别是java web开发的程序员，在使用servlet/jsp的时候，我们必须要知道实现页面跳转的两种方式的区别和联系：即转发和重定向的区别。 RequestDispatcher.forward方法只能将请求转发给同一个WEB应用中的组件；而HttpServletResponse.sendRedirect 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。如果传递给HttpServletResponse.sendRedirect 方法的相对URL以“/”开头，它是相对于整个WEB站点的根目录；如果创建RequestDispatcher对象时指定的相对URL以“/”开头，它是相对于当前WEB应用程序的根目录。 调用HttpServletResponse.sendRedirect方法重定向的访问过程结束后，浏览器地址栏中显示的URL会发生改变，由初始的URL地址变成重定向的目标URL；而调用RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址不变。 HttpServletResponse.sendRedirect方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的 访问请求，这个过程好比有个绰号叫“浏览器”的人写信找张三借钱，张三回信说没有钱，让“浏览器”去找李四借，并将李四现在的通信地址告诉给了“浏览器”。于是，“浏览器”又按张三提供通信地址给李四写信借钱，李四收到信后就把钱汇给了“浏览器”。可见，“浏览器”一共发出了两封信和收到了两次回复， “浏览器”也知道他借到的钱出自李四之手。RequestDispatcher.forward方法在服务器端内部将请求转发给另外一个资源，浏览器只知道发出了请求并得到了响应结果，并不知道在服务器程序内部发生了转发行为。这个过程好比绰号叫“浏览器”的人写信找张三借钱，张三没有钱，于是张三找李四借了一些钱，甚至还可以加上自己的一些钱，然后再将这些钱汇给了“浏览器”。可见，“浏览器”只发 出了一封信和收到了一次回复，他只知道从张三那里借到了钱，并不知道有一部分钱出自李四之手。 RequestDispatcher.forward方法的调用者与被调用者之间共享相同的request对象和response对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect方法调用者与被调用者使用各自的request对象和response对象，它们属于两个独立的访问请求和响应过程。对于同一个WEB应用程序的内部资源之间的跳转，特别是跳转之前要对请求进行一些前期预处理，并要使用HttpServletRequest.setAttribute方法传递预处理结果，那就应该使用RequestDispatcher.forward方法。不同WEB应用程序之间的重定向，特别是要重定向到另外一个WEB站点上的资源的情况，都应该使用HttpServletResponse.sendRedirect方法。 无论是RequestDispatcher.forward方法，还是HttpServletResponse.sendRedirect方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中。 两种跳转获得对象的方式123456//获得转发对象getRequestDispatcher()HttpServletRequest(httpServletRequest).getRequestDispatcherServletContext.getRequestDispatcher(); //获得重定向对象sendRedirect()HttpServletResponse(httpServletResponse).sendRedirect(); 转发和跳转的小结 转发使用的是getRequestDispatcher()方法;重定向使用的是sendRedirect(); 转发：浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变； 转发是服务器行为，重定向是客户端行为； 转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求； 转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。 转发和重定向的选择 重定向的速度比转发慢，因为浏览器还得发出一个新的请求，如果在使用转发和重定向都无所谓的时候建议使用转发。 因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了。 转发和重定向的应用场景在上面我已经提到了，转发是要比重定向快，因为重定向需要经过客户端，而转发没有。有时候，采用重定向会更好，若需要重定向到另外一个外部网站，则无法使用转发。另外，重定向还有一个应用场景：避免在用户重新加载页面时两次调用相同的动作。 例如，当提交产品表单的时候，执行保存的方法将会被调用，并执行相应的动作；这在一个真实的应用程序中，很有可能将表单中的所有产品信息加入到数据库中。但是如果在提交表单后，重新加载页面，执行保存的方法就很有可能再次被调用。同样的产品信息就将可能再次被添加，为了避免这种情况，提交表单后，你可以将用户重定向到一个不同的页面，这样的话，这个网页任意重新加载都没有副作用； 但是，使用重定向不太方便的地方是，使用它无法将值轻松地传递给目标页面。而采用转发，则可以简单地将属性添加到Model,使得目标视图可以轻松访问。由于重定向经过客户端，所以Model中的一切都会在重定向时丢失。但幸运的是，在Spring3.1版本以后，我们可以通过Flash属性，解决重定向时传值丢失的问题。 要使用Flash属性，必须在Spring MVC的配置文件中添加一个。然后，还必须再方法上添加一个新的参数类型：org.springframework.web.servlet.mvc.support.RedirectAttributes。 如下所示：123456789101112@RequestMapping(value="saveProduct",method=RequestMethod.POST)public String saveProduct(ProductForm productForm,RedirectAttributes redirectAttributes)&#123; //执行产品保存的业务逻辑等 //传递参数 redirectAttributes.addFlashAttribute("message","The product is saved successfully"); //执行重定向 return "redirect:/……";&#125; 参考自： 作者：liubin5620 来源：CSDN 原文：https://blog.csdn.net/liubin5620/article/details/79922692 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>后端小知识</category>
      </categories>
      <tags>
        <tag>页面跳转</tag>
        <tag>Web开发</tag>
        <tag>转发</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(七)]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下IP数据报的发送和转发过程(主机发送,路由器转发). 主机发送IP数据报的过程 路由器转发IP数据报的过程 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(六)]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦友情提示:今天是难啃的硬骨头，一分钟怕是不行 本小章隆重介绍一下IPv4地址,包括了分类地址,划分子网,构造超网以及定长和变长子网掩码. IPv4地址 IPv4地址就是给Internet上的每一个主机或路由器的每一个接口分配一个在全世界范围是唯一的32比特的标识符 IP地址由互联网名字和数字分配机构ICANN进行分配. 2011年2月3日,互联网号码分配管理局IANA宣布,IPv4地址已经分配完毕. 我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址,同时全面开展商用部署IPv6. IPv4地址的编址方法经历了三个历史阶段: IPv4地址的点分十进制表示方法 IPv4地址-分类地址 A类地址 B类地址 C类地址 分类地址的小结 IPv4地址-划分子网 划分子网的基本思想 子网掩码 默认的子网掩码 C类网可使用的子网掩码 B类网可使用的子网掩码 A类网可使用的子网掩码 C类网络快速划分子网示例 将网络号省略后便于观察 B类网络快速划分子网示例 只有一个字节的主机号不为0 两个字节的主机号都不为0 A类网络快速划分子网示例 只有一个字节的主机号不为0 有两个字节的主机号不为0 三个字节的主机号都不为0 划分子网的小结 IPv4地址-构造超网1234不知不觉讲到第三阶段了,在讲之前我们回头看看区别吧 *分类地址阶段的IP地址由&#123;网络号，主机号&#125;组成 *划分子网阶段的IP地址由&#123;网络号,子网号,主机号&#125;组成 *而构造超网阶段的IP地址由&#123;网络前缀,主机号&#125;组成 补充一些知识以便理解后面内容 无分类域间路由选择CIDR(Classes Inter-Domain Routing) CIDR消除了传统的A类、B类和C类地址以及子网划分的概念. 路由聚合(构造超网) 构造超网(无分类编址) CIDR使用”斜线记法”,或称CIDR记法,即在IPv4地址后面加上斜线”/“,在斜线后面写上网络前缀所占的比特数量. CIDR实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址块” 我们只要知道CIDR地址块中的任何一个地址,就可以回答以下五个问题: 地址块的最小地址 地址块的最大地址 地址块中的地址数量 地址块聚合某类(A,B,C类)网络的数量 地址掩码(也可以继续称为子网掩码) 下面举几个小例子加强理解吧例一: 例二: 例三: 定长的子网掩码和变长的子网掩码 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(五)]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章简单介绍一下虚拟局域网VLAN 虚拟局域网出现背景扩展以太网的同时也扩大了广播域 交换机是数据链路层的连接设备. 使用一个或多个交换机互联起来的交换式以太网,其所有站点都属于同一个广播域. 随着交换式以太网规模的扩大,广播域相应扩大. 巨大的广播域并不是一件好事,它会带来很多问题: 产生广播风暴 难以管理和维护 潜在的安全问题 网络中会频繁出现广播信息 使用TCP/IP协议栈时,很多协议都会使用广播(重要) ARP: 地址请求协议,(已知IP地址,找出其相应的MAC地址) RIP: 路由信息协议(一种小型的,内部路由协议) DHCP: 动态主机配置协议(用于自动配置IP地址) NetBEUI: Windows下使用的广播型协议(了解) IPX/SPX: Novell网络的协议栈(了解) AppleTalk: Apple公司的网络协议栈(了解) 如何分割广播域？ 使用路由器可以隔离广播域 路由器的成本较高 虚拟局域网VLAN技术应运而生 虚拟局域网VLAN 虚拟局域网VLAN(Virtual Local Area Network) 是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术, 这些逻辑组具有某些共同的需求. 例如 如何实现VLAN? 交换机上生成的各VLAN(逻辑组)是互不相通的. 实现VLAN间通信的方法: 使用路由器 使用三层交换机 VLAN的实现机制主要实现以下两部分内容功能,这里简单介绍不展开详细讲 (1) IEEE 802.1Q帧: 在以太网的原地址字段和类型字段之间插入4字节的VLAN标记(tag)字段,俗称”打标签” (2) 交换机的端口类型: Access Trunk Hybrid(华为私有) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(四)]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦这篇例外呢，难度挺大的，想着分两篇发，但还是一鼓作气吧，吃得苦中苦 本小章简单介绍一下集线器和交换机的区别， 以及交换机的内部工作原理(重点). 集线器和交换机的区别 以太网交换机的自学习算法以太网交换机的转发原理 交换机工作在数据链路层(也包括物理层) 交换机收到数据帧后，根据帧的目的MAC地址和交换机内部的帧交换表对帧进行处理. 明确的转发:交换机知道应当从哪个/哪些接口转发该帧(单播，多播，广播). 盲目的转发:交换机不知道应当从哪个端口转发帧,只能将其通过除进入交换机的接口外的其他所有接口转发(也称为泛洪). 明确的丢弃:交换机知道不应该转发该帧，将其丢弃. 交换机是一种即插即用设备,其内部的帧交换表是通过自学习算法自动地逐渐建立起来的. 登记MAC地址与接口号:提取帧的源mac地址,将其与该帧进入本交换机接口的接口号一起作为一个条目写入交换机的帧交换表 转发帧根据帧的目的MAC地址和交换机内部的帧交换表对帧进行处理(明确转发,盲目转发,丢弃). 帧交换表中每个条目都有自己的有效时间,到期删除:原因:12交换机的接口更换另一台主机主机更换网络适配器(网卡) 交换机的生成树协议STP-功能介绍 STP出现的背景在实际的网络拓扑中,我们会添加冗余链路以提高网络可靠性, 使得某段网络链路出现故障时整个网络仍可通信, 但增加冗余链路形成了网络环路, 网络环路所带来的问题： 1. 广播风暴(大量消耗网络资源，使得网络无法正常转发其他数据帧) 2. 主机收到重复的广播帧 3. 交换机的帧交换表震荡(漂移) 使用生成树协议STP解决网络环路问题以太网交换机使用生成树协议STP(Spanning Tree Protocol), 可以在提高网络可靠性的同时又避免网络环路带来的各种问题. 1. 不论交换机之间采用怎样的物理连接,交换机都能够自动计算并构建一个 逻辑上没有环路的网络,其逻辑拓扑结构必须是树型的(无逻辑环路). 2. 最终生成的树型逻辑拓扑要确保联通整个网络的每一个部分. 3. 当首次连接交换机或网络物理拓扑发生变化时(有可能是认为改变或故障), 交换机都将进行生成树的重新计算. 生成树算法STA生成树算法STA(Spanning Tree Algorithm)是生成树协议STP的核心. 它的实现目标是: 在包含有物理环路的网络中,构建出一个能够连通全网各节点的树型无环逻辑拓扑. 生成树算法的三个步骤: 1. &quot;选举&quot;根交换机 2. &quot;选举&quot;根端口 3. &quot;选举&quot;制定端口并阻塞备用端口 注意 “选举”根交换机 “选举”根端口 “选举”制定端口并阻塞备用端口 大致了解一下步骤吧以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(三)]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章简单介绍一下MAC地址，IP地址，以及ARP协议 计算机网络的寻址问题MAC地址MAC地址的作用 MAC地址的格式 标准表示法：XX-XX-XX-XX-XX-XX 例如，在Windows下00-0C-CF-93-8C-92 其他表示法：1.XX:XX:XX:XX:XX:XX 例如，在Linux,ios,Android下 00:0C:CF:93:8C:92 2.XXXX.XXXX.XXXX 例如，在Cisco Packet Tracer下000C.CF93.8C92 MAC地址的发送顺序12345字节发送顺序： 第一字节 → 第六字节字节内的比特发送顺序： b0 → b7 IP地址IP地址的作用 IP地址是互联网上各主机使用的地址，标识两部分信息：网络编号： 标识互联网上数以百万的网络 主机编号： 标识同意网络上不同的主机 很显然，之前介绍的MAC地址不具有这样的功能。12如果只是一个单独的网络，不连入互联网，可以只使用MAC地址。如果主机所在的网络连入互联网，则IP地址和MAC地址都使用。 从五层体系结构看IP地址与MAC地址 下面我们用一张图来看看数据包转发过程中IP地址与MAC地址的变化情况 具体的文字描述(可以加深理解转发过程) IP地址与MAC地址的关系 地址解析协议ARP1.在ARP高速缓存表中查找目的IP地址对应的MAC地址(因为在数据链路层需要封装该信息，如找不到则跳到第二步)2.广播发送ARP请求3.单播发送ARP响应4.ARP高速缓存表的更新(动态条目和静态条目)5.ARP作用范围：一段链路或同一网络内 补充一下内容吧,CSMA/CD协议没必要另写一章咯12345CSMA/CD曾经用于各种总线结构以太网和双绞线以太网的早起版本中.现在的以太网基于交换机和全双工连接，不会有碰撞，因此没必要使用CSMA/CD. CSMA/CD协议 其实不是很重要，初略记记英文单词就够了 载波监听多点接入/碰撞检测 Carrier Sense Multiple Access with Collision Detection 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(二)]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 计算机网络体系结构中的专用术语实体1任何可发送或接受信息的硬件或软件进程 对等实体1收发双方相同层次中的实体 协议1控制两个对等实体进行逻辑通信的规则的集合 协议的三要素 语法：定义所交换信息的格式 数据链路层帧格式举例：PPP帧，以太网MAC帧，802.11局域网数据帧 网络层数据包格式举例：IP数据报，ARP，ICMP，RIP，OSPF，BGP报文 运输层数据包格式举例：UDP用户数据报，TCP报文段 语义：定义收发双方所要完成的操作 同步：定义收发双方的时序关系 服务12在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层提供的服务。 服务访问点1在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型 例如: 链路层的服务访问点为帧的“类型”字段 网络层的服务访问点为IP数据报首部中的“协议”字段 运输层的服务访问点为端口号 服务原语1上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语 协议数据单元PDU1对等层次之间传送的数据包称为该层的协议数据单元 服务数据单元SDU1同一系统内，层与层之间交换的数据包称为服务数据单元 TCP/IP的四层体系结构 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(一)]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 计算机网络体系结构概述将实现互联网所面临的主要问题划分层次： 通过应用进程间的交互来完成特定网络应用 &emsp;&emsp;&emsp;应用层（DNS,DHCP,HTTP,SMTP,TELNET,FTP,P2P） 主机间的进程通信 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运输层1.将来自网络的数据包交给哪个应用进程(端口号)2.可靠传输服务和不可靠传输服务 数据包如何从原网络传到目的网络 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;网络层1.对各网络的标识(IP地址的网络号部分)2.数据包的路由(路由器的路由选择协议和转发机制) 数据包如何在一段链路上传输 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;数据链路层1.对主机和路由器的网络接口的标识(MAC地址)2.广播信道和点对点信道3.差错检测和可靠传输 主机，路由器等网络设备如何接入网络 &emsp;&emsp;&emsp;&emsp;&emsp;物理层1.使用何种的新号标识比特0和1(新号的调制和编码)2.使用何种物理接口(机械尺寸，引脚数量和排列) 分层思想 &emsp;OSI/RM体系结构 &emsp; &emsp;TCP/IP体系结构 &emsp; 五层协议体系结构 &emsp; 7 &emsp;&emsp;应用层 &emsp; 4 &emsp;应用层 &emsp; 5 &emsp;应用层 &emsp; &emsp; 6 &emsp;&emsp;表示层 &emsp; (HTTP,FTP,SMTP等) &emsp; &emsp; &emsp; &emsp; 5 &emsp;&emsp;会话层 &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; 4 &emsp;&emsp;运输层 &emsp; 3 &emsp;运输层(TCP或UDP) &emsp; 4 &emsp;运输层 &emsp; &emsp; 3 &emsp;&emsp;网络层 &emsp; 2 &emsp;网际层IP &emsp; 3 &emsp;网络层 &emsp; &emsp; &emsp;2 &emsp;数据链路层 &emsp; &emsp;1 &emsp;网络接口层 &emsp; &emsp;&emsp;2 &emsp;数据链路层 &emsp; &emsp; 1 &emsp;&emsp;物理层 &emsp; &emsp; &emsp; 1 &emsp;物理层 &emsp; 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Day In Github Pages]]></title>
    <url>%2F2019%2F03%2F31%2FMy-First-Day-In-Github-Pages%2F</url>
    <content type="text"></content>
      <categories>
        <category>essay[随笔]</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
</search>
