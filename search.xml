<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件过程管理复习攻略]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E7%AE%A1%E7%90%86%E5%A4%8D%E4%B9%A0%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[选择题Q1. 1.3 根据ISO/IEC15504，软件系统、产品的定义、设计、实现和维护等过程属于（ ） ( B ) A. 支持过程 B. 工程过程 C. 管理过程 D. 客户-供应商过程 Q2. 2.1 过程改进的价值是（ ） ( D ) A. 缩短研发周期，提高生产率 B. 改进质量，提高客户满意度 C. 改进进度/预算的可预测性，提高投资回报率 D. 以上都是 Q3. 2.2 CMMI模型中，负责组织的技能和资源管理，为项目提供具备合适技能的项目成员的PAs是（ ） ( D ) A. PP（Project Plan） B. PMC（Project Monitor and Control） C. IPM（Integrated Project Management） D. OT(Organizational Training) Q4. 2.4 CMMI模型中，涉及对现有的设计中的技术质量问题检出的PA是（ ） ( C ) A. PP（Project Plan） B. PMC（Project Monitor and Control） C. VER（Verification） D. PPQA(Product and Process Quality Assurance) Q5. 2.6 CMMI 模型的PAs中，以下不属于工程域的是（ ） ( C ) A. ReqM（Requirement Management） B. PI（Product Integration） C. PMC（Project Monitor and Control） D. VER (Verfication) Q6. 2.15 CMMI可以作为（ ） ( D ) A. 过程评估（SCAMPI）的检查单 B. 过程改进的指导书 C. 过程审计的依据 D. 以上都是 Q7. 3.2 组织过程焦点的执行能力不包含（ ） ( B ) A. 建立一个负责整个组织的软件过程活动的工作组 B. 高级管理人员监督软件过程的制定和改进的组织活动 C. 为软件过程活动提供足够的资源和资金 D. 组织软件过程活动的组员进行培训 Q8. 3.3 组织过程焦点的执行约定不包含（ ） ( B ) A. 组织应该遵循一个文档化的关于协调软件流程的制定和改进活动的组织方针 B. 建立一个负责整个组织的软件过程活动的工作组 C. 高级管理人员发起对软件过程制定和改进的组织活动 D. 高级管理人员监督软件过程的制定和改进的组织活动 Q9. 3.4 组织软件过程财富不包含（ ） ( D ) A. 组织标准软件过程 B. 软件生命周期的描述 C. 过程剪裁指南和准则 D. 数据库管理系统 Q10. 4.5 在需求跟踪过程中，检查设计文档、代码、测试用例等工作成果是否都能在《产品需求规格说明书》中找到出处的方法属于（ ） ( A ) A. 逆向跟踪 B. 正向跟踪 C. 双向跟踪 D. 系统跟踪 Q11. 4.6 以下关于需求分析的叙述中，不正确的是（ ） ( B ) A. 需求分析的目的是确定系统必须完成哪些工作，对目标系统提出完整、准确、清晰、具体的要求 B. 完整的需求分析过程包括：获取用户需求、分析用户需求、编写需求说明书三个过程 C. 根据项目的复杂程度，需求分析的工作可以由专门的系统分析人员来做，也可以由项目经理带领技术人员完成 D. 软件需求分为三个层次：业务需求、用户需求、功能需求与非功能需求 Q12. 4.7 以下（）不是获取需求的方法。 ( D ) A. 问卷调查 B. 会议讨论 C. 获取原型 D. 决策分析 Q13. 4.8 项目的需求文档应精准描述要交付的产品，应能反映出项目的变更。当不得不作出变更时，应该（ ）对被影响的需求文件进行处理。 ( C ) A. 从关注高层系统需求变更的角度 B. 从关注底层功能需求变更的角度 C. 按照从高层到底层的顺序 D. 按照从底层到高层的顺序 Q14. 4.9 以下关于软件需求变更的叙述中，不正确的是（） ( D ) A. 每一个需求变更都必须能追溯到一个经核准的变更请求 B. 变更控制过程本身应该形成文档 C. 所有需求变更必须遵循变更控制过程 D. 需求变更后，可以删除原始的需求文档 Q15. 4.10 以下关于软件需求分析的叙述中，不正确的是（ ） ( A ) A. 软件需求分析阶段的任务时描述出软件架构及相关组件之间的接口 B. 软件需求分析可以检测和解决需求之间的冲突 C. 软件需求分析可以确定系统的边界 D. 软件需求分析是软件工程过程中的一个关键过程 Q16. 4.11 在进行项目需求管理时，某需求的状态描述是“该需求已被分析，估计了其对项目余下部分的影响，已用一个明确的产品版本号或创建编号分配到相关的基线中，软件开发团队已同意实现该需求”，则这个需求状态是（ ） ( D ) A. 已建议 B. 已验证 C. 已实现 D. 已批准 Q17. 4.12 在用UML对信息系统建模过程中，（ ）用来描述用户需求，主要从用户的角度描述系统的功能。 ( A ) A. 用例图 B. 类图 C. 对象图 D. 部署图 Q18. 4.13 软件需求包括三个不同的层次，分别为业务需求、用户需求和系统需求。（ ）属于用户需求。 ( B ) A. 反应了组织机构或客户对系统、产品高层次的目标要求，其在项目视图范围文档中予以说明 B. 描述用户使用产品必须要完成的任务，其在使用实例文档或方案脚本说明中予以说明 C. 定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从中满足了业务需求 D. 软件产品为了满足用户的使用，对用户并发、处理速度、安全性能等方面需求 Q19. 4.14 以下关于需求跟踪的叙述中，（ ）是不正确的。 ( D ) A. 逆向需求跟踪检查设计文档、代码、测试用例等工作产品是否都能在《需求规格说明书》中找到出处 B. 需求跟踪矩阵可以把每个需求与业务目标或项目目标联系起来 C. 需求跟踪矩阵为管理产品范围变更提供框架 D. 如果按照“需求开发-系统设计-编码-测试”这样的顺序开发产品，由于每一步的输出就是下一步的输入，所以不必担心设计、编程、测试会与需求不一致，可以省略需求跟踪 Q20. 5.1 某软件开发项目在测试时发现需求需要调整，涉及到需求规格说明书、概要设计、详细设计及代码等相关文档的变更，需要对（ ）进行变更控制。 ( B ) A. 知识库 B. 配置库 C. 产品库 D. 数据库 Q21. 5.2 软件设计过程是定义一个系统或组件（1）的过程，其中描述软件的结构和组织，标识各种不同组件的设计是（2） ( D ) A. （1）数据和控制流 （2）软件详细设计 B. （1）数据和控制流 （2）软件架构设计 C. （1）架构和接口 （2）软件详细设计 D. （1）架构和接口 （2）软件架构设计 Q22. 5.3 典型的信息系统项目开发的过程中，（1）阶段拟定了系统的目标、范围和要求，而系统各模块的算法一般在（2）阶段制定 ( B ) A. （1）需求分析 （2）概要设计 B. （1）需求分析 （2）详细设计 C. （1）需求管理 （2）概要设计 D. （1）需求管理 （2）详细设计 Q23. 7.1 以下（ ）是一种静态分析技术或评审过程，在此过程中，设计者或程序员引导开发组的成员通读已书写的设计或者代码，其他成员负责提出问题，并对有关技术风格、风格、可能的错误、是否违背开发标准等方面进行评论。 ( A ) A. 走查 B. 审计 C. 认证 D. 鉴定 Q24. 5.4 使用UML对系统进行分析设计时，需求描述中的“包含”，“组成”“分为——部分”等词常常意味着存在（ ）关系。 ( B ) A. 继承 B. 聚集 C. 泛化 D. 依赖 Q25. 5.5 软件架构是软件开发过程中的一项重要工作，（ ）不属于软件架构设计的主要工作内容。 ( B ) A. 制定技术规格说明 B. 编写需求规格说明书 C. 技术选型 D. 系统分解 Q26. 5.6 （ ）是软件系统结构中各个模块之间相互联系紧密程度的一种度量 ( B ) A. 内聚性 B. 耦合性 C. 层次性 D. 关联性 Q27. 5.7 以下关于软件测试的描述，不正确的是（ ） ( B ) A. 为评价和改进产品质量进行的活动 B. 必须在编码阶段完成后才开始的活动 C. 是为识别产品的缺陷而进行的活动 D. 一般分为单元测试、集成测试、系统测试等阶段 Q28. 5.8 以下关于软件测试的叙述中，不正确的是（ ） ( D ) A. 在集成测试中，软件开发人员应该避免测试自己开发的程序 B. 软件测试工作应该在需求阶段就开始进行 C. 如果软件测试完成后没有发现任何问题，那么应首先检查测试过程是否存在问题 D. 如果项目时间比较充裕，测试的时间可以长一些，如果项目时间紧张，测试时间可以少一些 Q29. 5.9 软件测试是软件开发过程中的一项重要内容，将测试分为白盒测试、黑盒测试主要是（ ）对软件测试进行分类 ( A ) A. 从是否关心软件内部结构和具体实现的角度 B. 从是否执行程序的角度 C. 从软件开发阶段的细分角度 D. 从软件开发复杂性的角度 Q30. 7.2 某软件系统经测试发现有错误并不能满足质量要求，为了纠正其错误投入了10人天的成本，该成本（） ( C ) A. 不属于质量成本 B. 属于质量成本的一致成本 C. 属于质量成本中的故障成本 D. 属于质量成本中的评估成本 Q31. 5.10 （ ）指为了检测由于代码修改而可能引入的错误所进行的测试活动 ( A ) A. 回归测试 B. 集成测试 C. 压力测试 D. 系统测试 Q32. 6.1 关于软件配置管理的描述，不正确的是（） ( A ) A. 配置控制委员会成员必须是专职人员 B. 配置库包括动态库（开发库），受控库（主库）、静态库（产品库） C. 常用的配置管理工具有SVN、GIT等 D. 配置项的状态分为草稿、正式和修改三种 Q33. 6.2 如果你正在为一个新的信息系统研发项目识别可能的风险，得知某项目团队刚刚发生了一起代码意外泄露的安全事件。此时应该使用（ ）方法进行信息收集。 ( C ) A. 德尔菲 B. 访谈 C. 根本原因识别 D. 头脑风暴 Q34. 6.3 A公司刚刚中标一个大型系统集成项目，其中一台设备计划从国外采购，近期汇率波动明显，A公司准备与客户协商使用国产设备进行替代，这是采用了（ ）风险应对策略。 ( A ) A. 回避 B. 转移 C. 减轻 D. 接受 Q35. 6.4 在项目配置项与基线的变更控制中，（ ）是配置管理员的主要工作。 ( D ) A. 确定受变更影响的关联配置项和有关基线 B. 将变更申请的决议通知受此变更影响的每个干系人 C. 组织修改配置项，并在相应的文档或程序代码中记录变更信息 D. 将变更后的配置项纳入基线，并将变更内容和结果通知相关人 Q36. 6.5 成本预算的输入不包括（） ( D ) A. 资源日历 B. 风险登记册 C. 协议 D. 成本基准 Q37. 6.6 控制成本过程输出，不包括（ ） ( A ) A. 项目资金需求 B. 项目文件更新 C. 工作绩效信息 D. 成本预测 Q38. 6.7 小王在设计测试用例时，由于忽视了边界条件、异常处理等情况，没有完全覆盖需求。这类风险属于测试工作中的（ ） ( A ) A. 测试用例风险 B. 缺陷风险 C. 代码质量风险 D. 测试环境风险 Q39. 6.8 质量规划管理过程的事业环境因素不包括（ ） ( D ) A. 可能影响项目质量的工作条件或运行条件 B. 特定应用领域的相关规则、标准和指南 C. 可能影响质量期望的文化观念 D. 以往阶段或项目的经验教训 Q40. 6.9 以下（ ）旨在建立对未来输出或正在进行的工作在完工时满足特定的需求和期望的信心。 ( C ) A. 质量控制 B. 质量规划 C. 质量保证 D. 质量改进 Q41. 6.10 关于项目目标的描述，不正确的是（ ） ( B ) A. 项目可以有一个目标，也可以有多个目标 B. 项目目标可以量化，也可以不量化 C. 项目的成果目标与约束目标可能会冲突 D. 项目目标应该是具体的、可实现的 Q42. 6.11 关于工作分解结构WBS的描述，不正确的是( ) ( B ) A. WBS必须且只能包括100%的工作 B. WBS的元素必须指定一个或多个负责人 C. WBS 应该由全体项目成员、用户和项目干系人一致确认 D. 分包出去的工作也应纳入WBS中 Q43. 6.12 A公司承接了某银行网上银行系统的建设项目，包括应用软件开发、软硬件集成适配、系统运维等多项工作内容。针对该项目，不正确的是（ ） ( B ) A. 该项目的干系人包括客户、公司高层领导、项目成员及网上银行用户 B. 干系人管理工作应由该项目成员分工负责 C. 干系人管理有助于为项目赢得更多的资源 D. 通常来说，干系人对项目的影响能力在项目启动阶段最大，随着项目的进展逐渐减弱 Q44. 6.13 以下关于质量保证的叙述中，不正确的是（ ） ( B ) A. 实施质量保证是确保采用合理的质量标准和操作性定义的过程 B. 实施质量保证是通过执行产品检查并发现缺陷来实现的 C. 质量测量指标是质量保证的输入 D. 质量保证活动可由第三方团队进行监督，适当时提供服务支持 Q45. 6.14 在风险识别时，可以用到多种工具和技术。其中（ ）指的是从项目的优势、劣势、机会和威胁出发，对项目进行考察，从而更全面地考虑风险。 ( C ) A. 头脑风暴法 B. 因果图 C. SWOT分析法 D. 专家判断法 Q46. 6.15 项目范围基准包括（ ） ( A ) A. 批准的项目范围说明书、WBS及WBS字典 B. 项目初步范围说明书、WBS及WBS字典 C. 批准的项目范围说明书，WBS字典 D. 项目详细范围说明书、WBS Q47. 6.16 项目经理对项目负责，其正式权利由（ ）获得 ( D ) A. 项目工作说明书 B. 成本管理计划 C. 项目资源日历 D. 项目章程 Q48. 6.17 质量管理工具（ ）常用于找出导致项目问题产生的潜在原因 ( B ) A. 控制图 B. 鱼骨图 C. 散点图 D. 直方图 Q49. 6.18 以下关于软件版本控制的叙述中，正确的是（ ） ( B ) A. 软件开发人员对源文件的修改在配置库中进行 B. 受控库用于管理当前基线和控制对基线的变更 C. 版本管理与发布由CCB执行 D. 软件版本升级后，新基线存入产品库且版本号更新，旧版本可删除 Q50. 6.19 以下关于质量保证的叙述中，不正确的是（ ） ( B ) A. 质量保证应该贯穿整个项目生命期 B. 质量保证活动属于监控过程组 C. 质量保证是为了建立对产品或服务的信心 D. 质量保证通常由独立第三方完成 Q51. 6.20 项目工作说明书是对项目所需要提供的产品、成果或服务的描述。其内容一般不包括（ ） ( D ) A. 业务要求 B. 产品范围描述 C. 项目目标 D. 技术可行性分析 Q52. 6.21 用德尔菲方法估算一个活动的成本，三个回合后的结果如下表所示（数值表示活动时间），如果每小时的成本是40美元。那么可能的成本应该是（ ）美元 ( ) [这道题不懂T T] A. 880 B. 800 C. 200 D. 900 Q53. 6.22 项目经理小李对自己的项目采用挣值法进行分析后，发现SPI&gt;1、CPI&lt;1。则该项目（ ） ( B ) A. 进度超前，成本节约 B. 进度超前，成本超支 C. 进度延后，成本节约 D. 进度延后，成本超支 Q54. 6.23 在项目质量计划编制过程常用的工具和技术中（）是将实际实施过程中或计划之中的项目做法同其他类似项目的实际做法进行比较，改善与调高项目的质量。 ( D ) A. 成本/效益分析 B. 试验设计 C. 质量成本 D. 基准分析 Q55. 6.24 某项目范围基础发生变化，经变更控制委员会同意，对需求规格说明书进行变更，则该配置项的状态应从（ ） ( B ) A. “草稿”变迁为“正在修改” B. “正式发布”变迁为“正在修改” C. “Check in”变迁为“Check out” D. “Check out”变迁为“Check in” Q56. 6.25 以下关于信息系统项目风险的叙述中，不正确的是（） ( C ) A. 信息系统项目风险是一种不确定性或条件，一旦发生，会对项目目标产生积极或消极的影响 B. 信息系统项目风险既包括对项目目标的威胁，也包括对项目目标的机会 C. 具有不确定性的事件是信息系统项目风险定义的充分条件 D. 信息系统项目的已知风险是哪些已经经过识别和分析的风险，其后果也可以预见 Q57. 6.26 进度风险导致的损失不包括（） ( C ) A. 货币的时间价值 B. 延期投入导致的损失 C. 预算不准导致的成本超支 D. 进度延误引起的第三方损失 Q58. 6.27 以下关于成本预算的叙述中，不正确的是（ ） ( B ) A. 成本预算过程完成后，可能会引起项目管理计划的更新 B. 管理储备是为范围和成本的潜在变化而预留的预算，需要体现在项目成本基线中 C. 成本基准计划可以作为度量项目绩效的依据 D. 成本基准按时间分段计算，通常以S曲线的形式表示 Q59. 6.28 项目进行到某阶段时，项目经理进行绩效分析，计算出CPI值为1.09，这表示（ ） ( B ) A. 每花费109元人民币，只创造相当于100元的价值 B. 每花费100元人民币，可创造相当于109元的价值 C. 项目进展到计划进度的109% D. 项目超额支出9%的成本 Q60. 6.29 成本控制过程的主要内容不包括（） ( A ) A. 将项目的成本分配到项目的各项具体工作上 B. 识别可能引起项目成本基准计划发生变动的因素，并对这些因素施加影响 C. 对发生成本偏差的工作包实施管理，有针对性地采取纠正措施 D. 对项目的最终成本进行预测 Q61. 6.30 配置项的状态有三种：草稿、正式发布和正在修改。以下叙述中，不正确的是（ ） ( D ) A. 配置项刚建立时状态为“草稿”，通过评审后，状态变为“正式发布” B. 配置项的状态变为“正式发布”后，若需要修改必须通过变更控制流程进行 C. 已发布的配置项通过了CCB的审批同意修改，此时其状态变为“正在修改” D. 通过了变更控制流程审批的配置项，修改完成后即可发布，其状态再次变为“正式发布” Q62. 6.31 项目进度控制是依据项目进度基准计划对项目的实际进度进行监控，使项目能够按时完成，以下关于项目进度控制的叙述中（ ）是不正确的 ( D ) A. 进度控制必须与其他变化控制，包括成本控制与范围控制紧密结合 B. 项目进度控制是项目整体控制的一个组成部分 C. 对项目进度的控制，应重点关注项目进展报告和执行状态报告 D. 项目进度至关重要，因此进度控制需要在项目初期优先关注 Q63. 6.32 项目质量管理通过质量规划、质量保证、质量控制程序和过程以及连续的过程改进活动来实现，其中（ ）关注项目执行过程中的质量 ( A ) A. 质量保证 B. 质量规划 C. 质量控制 D. 质量改进 Q64. 6.33 （ ）提供了一种结构化方法以便使风险识别的过程系统化、全面化，保证组织能够在一个统一的框架下进行风险识别，目的是提高风险识别的质量和有效性。 ( B ) A. 风险影响力评估 B. 风险类别 C. 风险概率分析 D. 风险管理的角色界定 填空题填空1Q1. 1.1 过程是指一组将输入转化为输出的相互关联或相互作用的活动，活动由（ ）、实施活动和（ ）三个环节组成。（10分）正确答案： 输入，输出Q2. 1.2 过程一般可以分为：产品实现过程、（ ）和（ ）。（10分）正确答案： 管理过程和支持过程Q3. 1.6 软件生命周期是软件获取、供应、开发、（ ）和（ ）的过程（10分）正确答案： 运行和维护Q4. 2.3 CMMI中过程域分为四大类：（ ）、（ ）、过程管理、以及支持管理（10分）正确答案： 工程管理，项目管理Q5. 2.5 CMMI将能力成熟度分为5个等级，分别是：初始级,（ ）,已定义级,（ ）,优化级。（10分）正确答案： 已管理级，量化管理级Q6. 2.16 CMMI模型能力成熟度等级的达成，意味着必须达成该等级适用PA的（ ）和（ ）。（10分）正确答案： 通用目标，特定目标Q7. 4.1 软件需求按层次划分，可分为业务需求、（ ）、及系统需求。（10分）正确答案： 用户需求Q8. 4.2 所有与需求直接相关的活动统称为需求工程，需求工程一般分为两个部分：（ ）和需求管理。（10分）正确答案： 需求开发 / 需求定义（选择一个）Q9. 4.3 请列举三种需求获取方法：（ ）、（ ）、（ ）。（10分）正确答案： 需求研讨会 头脑风暴 用例模型 访谈 原型法 角色扮演（选择3个） 填空2Q1. 软件过程财富是组织在软件过程改进过程中积累而得到的用于指导软件项目的过程文档和数据等重要信息。软件过程财富包括（ ）、（ ）、（ ）、组织软件过程数据库、软件过程的有关文档库。（10分）正确答案： 组织标准软件过程、软件生命周期的描述、过程裁剪指南和准则Q2. CMMI将软件过程不同的成熟度分为（ ）个等级。（10分）正确答案： 5Q3. PSP是一个具有4个成熟度等级的框架，这4个等级是（ ）、（ ）、（ ）、及个体循环过程。（10分）正确答案： 个体度量过程、个体计划过程、个体质量管理过程Q4. PMI BOK （第5版）项目管理知识体系包括（ ）个知识域。全部项目管理过程被分为（ ）个管理过程组。（10分）正确答案： 10，5Q5. 判断项目是否成功的核心要素是项目的（ ）、（ ）、（ ）、及质量。（10分）正确答案： 范围、成本、时间Q6. 请列举PMI BOK （第5版）项目管理知识体系的10个知识域中的任意5个：（ ）、（ ）、（ ）、（ ）、（ ）（10分）正确答案： 整合管理、范围管理、时间管理、成本管理、质量管理、风险管理、人力资源管理、沟通管理、干系人管理、采购管理Q7. PMI BOK （第5版）将管理过程分为5个管理过程组，这5个管理过程组是（ ）、（ ）、（ ）、（ ）、（ ）。（10分）正确答案： 启动过程组、规划过程组、执行过程组、监控过程组、收尾过程组Q8. 软件过程的技术架构是指用于支持（）过程成功实现与（） 的技术基础设施。（10分）正确答案： 软件工程过程、过程改进 简答题Q1. 1.4 实施软件过程管理并遵循过程规范的目的是什么？（10分）正确答案： 软件过程管理可以为快速开发高质量软件、有效地维护软件运行等各类活动提供指导性框架、实施方法和最佳实践。软件过程规范可以保证过程活动的一致性、有效性和持续性。其最终目的是以低成本生产高质量的软件产品。 Q2. 1.5 什么是软件过程规范，实施软件过程规范的积极作用有哪些？（10分）正确答案： 过程规范就是对输入/输出和活动所构成的过程进行明文规定或约定俗成的标准。软件过程规范是软件开发组织行动的准则与指南，可以依据上述各类过程的特点而建立相应的规范，如软件基本过程规范、软件支持过程规范和软件组织过程规范。 1) 帮助团队实现共同的目标； 2) 一个规范的软件过程必能带来稳定的、高水平的过程质量，确保产品的高质量； 3) 建立一致、稳定和可靠的质量水平。 4)过程规范执行的结果使得团队具有统一、协调、规范的行动与工作方式。使得软件组织的生产效率更高。 Q3. 2.7 CMMI 2级和CMMI 3级关注的目标有什么不同？（10分）正确答案： CMMI 2级关注于项目级别的管理，以每个里程碑的管理为重点，期望项目能够按照计划达到项目的目标。 CMMI 3级关注于组织的所有项目按照统一的标准过程执行项目，使用和维护组织过程财富库，以项目的里程碑的内部可见性的管理为重点，期望组织能持续稳定的产出高质量的工作产品为目标。 Q4. 1.7 试分析在以下情况应该采用哪种软件过程模型进行开发，为什么？ 1. 为咖啡馆开发一个付费系统。该系统使用指纹识别器和触摸屏。指纹识别系统用来识别客人，然后客人可以通过触摸屏选择咖啡。最后客人离开时可以通过指纹识别身份并付账。系统需求相对清晰。 2. 为一家工厂开发一个存货控制系统。系统包含许多低耦合的子系统。客户对他们的管理熟悉并清楚知道系统需要完成什么功能。最初对系统的描述展示了一个相对较大的需求，并且有些功能并不是需要立即交付。 3. 客户想要开发一个房屋安全监测系统。客户认为该系统将会有很大的市场潜力并具有很高的热情。客户对软件开发并不了解，因此不能很好地描述系统。但他们有深厚的领域知识。（10分）正确答案： 1. 项目规模较小且需求相对清晰，可以使用瀑布模型 2. 需求规模较大，且子系统间耦合较低，可采用增量模型。螺旋模型亦可，但不如增量模型 3. 客户不能较好描述需求，且风险大，可采用螺旋模型。原型模型亦可，但没充分考虑风险，不如螺旋模型。 Q5. 3.1 试述PSP、TSP以及CMMI之间的关系（10分）正确答案： 三者相互配合，互有侧重，可以形成一个有机整体。 CMMI是过程改进的第一步，它提供了评价组织的能力、识别优先改进需求和追踪过程改进的管理方式。CMMI为企业软件过程建设与改进提供指南。企业只有实施CMMI后，才能认识到自身的不足，才能注重对员工能力的培养，合理分配项目人员，并且建立起有效的项目小组。 PSP (Personal Software Process)即个人软件过程,是一种可用于控制、管理和改进个人工作方式的自我持续改进过程。PSP帮助软件工程师作出准确的计划；确定软件工程师为改善产品质量要采取的步骤；建立度量个体软件过程改善的基准；是实施TSP及CMMI的基础保障。 TSP（Team Software Process）即小组软件过程，是为开发软件产品的开发团队提供指导，TSP的侧重于帮助开发团队改善其质量和生产率。目标是在企业过程管理框架下，对过程标准及规范进行裁剪，在有限的资源和时间内实现项目目标。TSP是企业实施CMMI的具体体现，并将工程师的个体过程PSP融入小组软件过程。 Q6. 3.5 简述定义项目所用软件过程，即裁剪组织标准软件过程的流程。（10分）正确答案： 如图 Q7. 4.4 简述为什么需要需求评审？（10分）正确答案： 1. 成本要求 2. 技术要求 Q8. 6.34 简述项目范围的定义（10分）正确答案： 在项目环境中，“范围”这一术语有两种含义： 产品范围——某项产品、服务或成果所具有的特性和功能 项目范围——为交付具有规定特性与功能的产品、服务或成果而必须完成的工作。项目范围有时也包括产品范围 Q9. 6.35 简述三种需求收集技术（10分）正确答案： 1. 访谈，是通过与干系人直接交谈来获取信息的正式或非正式的方法。 2. 焦点小组，是召集预定的干系人和主题专家，了解他们对所讨论的产品、服务或成果的期望和态度。 3. 引导式研讨会，把主要干系人召集在一起，通过集中讨论来定义产品需求。研讨会是快速定义跨职能需求和协调干系人差异的重要技术。 4. 群体创新技术，如头脑风暴法，名义小组技术，概念/思维导图等。 5. 问卷调查 6. 观察 7. 原型法 Q10. 6.36 什么是确认范围，其与质量控制的关系（10分）正确答案： 确认范围是正式验收已完成的项目可交付成果的过程。本过程的主要作用是，使验收过程具有客观性； 确认范围过程与控制质量过程的不同之处在于，前者关注可交付成果的验收，而后者关注可交付成果的正确性及是否满足质量要求。控制质量过程通常先于确认范围过程，但二者也可同时进行。 Q11. 6.37 简述类比估算的含义及其优缺点（10分）正确答案： 类比估算是一种使用相似活动或项目的历史数据，来估算当前活动或项目的持续时间或成本的技术。类比估算以过去类似项目的参数值（如持续时间、预算、规模、重量和复杂性等）为基础，来估算未来项目的同类参数或指标。这是一种粗略的估算方法，有时需要根据项目复杂性方面的已知差异进行调整。在项目详细信息不足时，就经常使用这种技术来估算。相对于其他估算技术，类比估算通常成本较低、耗时较少，但准确性也较低。 Q12. 6.38 简述应急储备与管理储备（10分）正确答案： 应急储备是包含在成本基准内的一部分预算，用来应对已经接受的已识别风险，以及已经制定应急或减轻措施的已识别风险。应急储备通常是预算的一部分，用来应对那些会影响项目的“已知—未知”风险。也可以估算项目所需的管理储备。管理储备是为了管理控制的目的而特别留出的项目预算，用来应对项目范围中不可预见的工作。管理储备用来应对会影响项目的“未知—未知”风险。 Q13. 6.39 简述质量成本的内容（10分）正确答案： 质量成本包括在产品生命周期中为预防不符合要求、为评价产品或服务是否符合要求，以及因未达到要求（返工），而发生的所有成本。 质量成本一般包括：为确保与要求一致而作的所有工作叫做一致成本，以及由于不符合要求而引起的全部工作叫做不一致成本，这些工作引起的成本主要包括：预防成本、鉴定成本、内部损失成本和外部损失成本。其中预防成本和鉴定成本属于一致成本，而内部损失成本和外部损失成本，又统称为故障成本，属于不一致成本。 Q14. 6.41 简述质量保证与质量控制的区别（10分）正确答案： 质量保证是审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程。质量保证旨在建立对未来输出或未完输出（也称正在进行的工作）将在完工时满足特定的需求和期望的信心。质量保证通过用规划过程预防缺陷，或者在执行阶段对正在进行的工作检查出缺陷，来保证质量的确定性。 控制质量是监督并记录质量活动执行结果，以便评估绩效，并推荐必要的变更的过程。控制质量过程使用一系列操作技术和活动，来核实已交付的输出是否满足需求。主要作用包括：识别过程低效或产品质量低劣的原因，建议并/或采取相应措施消除这些原因；确认项目的可交付成果及工作满足主要干系人的既定需求，足以进行最终验收。 在项目规划和执行阶段开展质量保证，来建立满足干系人需求的信心；在项目执行和收尾阶段开展质量控制，用可靠的数据来证明项目已经达到发起人和/或客户的验收标准。 Q1. 关于集成产品开发（IPD），请回答：（1）IPD模型中的4个核心流程是什么？（2）IPD模型中的4个跨部门团队是什么？（3）IPD模型中产品开发流程包括那几个阶段？（4）IPD模型中产品开发流程包括那几个决策评审？（10分）答案：（1）战略管理流程、市场管理流程、产品开发流程、技术开发及平台开发流程 （2）集成组合管理团队IPMT(Integrated Portfolio Management Team) 组合管理团队PMT（Portfolio Management Team） 产品开发团队PDT（Product Development Team） 技术开发团队TDT（Technology Development Team） （3）概念、计划、开发、验证、发布、生命周期管理 （4）概念评审CDCP、计划评审PDCP、可获得性评审ADCP、生命周期结束评审LDCP （5）六个技术评审点：产品需求和概念、需求分解和规格、总体方案、工程图纸、样机、小批量 Q2. 简述软件过程评估的目的。（10分）答案：软件过程评估的目的是对当前组织内部所运行的软件过程能力和性能等状态进行准确的、客观的描述，试图发现当前过程实施的特点，标识出其中的强项与弱项，使将来发挥强项、克服弱项，更好地控制过程、改进过程，避免在质量、成本以及进度方面出现重大的问题。 计算题1.某项目经理在对项目历时进行估算时，认为正常情况下完成项目需要80天，同时也分析了影响项目工期的因素，认为最快可以在66天内完成工作，而在最不利的条件下则需要100天完成任务。（1）采用三点估算得到的工期。（2）项目历时估算的标准差。（3）项目在84天内完成的可能性。（66+80*4+100）/6=81(100-66)/6=5.7天84天在1σ以内，而且在期望值81之后，所以=50%+68.26%/2=84.13% 2.某信息系统项目包含如下七个活动。各活动的历时、活动逻辑关系如下表所示：活动名称 活动历时（天） 前置活动A 4 B 10 AC 4 B,DD 12 AE 6 C,GF 6 AG 8 F假设该项目的成本基准是25万元。当项目进行到某一天时，项目实际完成的工作量仅为应完成工作的80%，此时的PV为20万元，实际花费为24万元。（1）请给出该项目的关键路径和总工期。（2）请给出活动E、G的总浮动时间。（3）对各项活动测算发现，只有活动B、D有可能缩短工期，其余活动均无法缩短工期。如果将工期缩短2天，则工期应该如何压缩。（4）请计算当前时点的EV、CV、SV。（5）在当前绩效情况下，请计算该项目的完工尚需估算ETC和完工估算EAC。 (1)关键路径：ADCE； 工期：26天(2)(2) C总浮动时间：0天； G总浮动时间：2天(3) 可将D由12天压缩为10天；(4) EV = 20*0.8 = 16万元CV = EV – AC = 16 – 24 = -6万元SV = EV – PV = 16 – 20= -4万元(5) ETC = (BAC-EV)/CPI = (25-16)/(16/24) = 13.5万元 EAC = ETC + AC = 24+13.5 = 37.5万元 大题知识点必知必会1. 估算活动持续时间的方法三点估算(未全) 通过考虑估算中的不确定性和风险，可以提高活动持续时间估算的准确性。这个概念源自计划评审技术（PERT, Project Evaluation and Review Technique ）。 最可能时间（tM）。基于最可能获得的资源、最可能取得的资源生产率、对资源可用时间的现实预计、资源对其他参与者的可能依赖及可能发生的各种干扰等，所估算的活动持续时间。 最乐观时间（tO）。基于活动的最好情况，所估算的活动持续时间 最悲观时间（tP）。基于活动的最差情况，所估算的活动持续时间 基于持续时间在三种估算值区间内的假定分布情况（β分布），使用公式来计算期望持续时间tE。1tE = ( tO + 6 * tM + tP ) / 6 2. 关键路径法看ppt的例子就好了，很简单 3. 估算成本PERT估算 4. 挣值管理 计划价值（Planned Value，PV）是为计划工作分配的经批准的预算。它是为完成某活动或工作分解结构组件而准备的一份经批准的预算，不包括管理储备。在某个给定的时间点，计划价值代表着应该完成的工作。 项目的总计划价值又被称为完工预算（Budget at Completion，BAC）。 挣值（Earned Value，EV）是对已完成工作的测量值。挣值的度量方法Binary schemeEV=0 if the task is not completedEV=PV if the task is completedPartial schemeEV=PV X p%, where p% is the percentage of completed work against the task项目经理既要监测EV的增量，以判断当前的状态，又要监测EV的累计值，以判断长期的绩效趋势。 实际成本（Actual Cost，AC）是在给定时段内，执行某工作而实际发生的成本，是为完成与EV相对应的工作而发生的总成本。AC没有上限，为实现EV所花费的任何成本都要计算进去。 通过PV，EV，AC可以监测实际绩效与基准之间的偏差进度偏差（Schedule Variance，SV）成本偏差（Cost Variance，CV）进度绩效指数（Schedule Performance Index，SPI）成本绩效指数（Cost Performance Index，CPI） 进度偏差（Schedule Variance，SV）是测量进度绩效的一种指标，表示为挣值与计划价值之差。SV = EV – PV进度偏差是一种有用的指标，它是指在某个给定的时点，项目进度是落后还是提前于进度基准。SV&gt;0 提前SV=0 基准SV&lt;0 落后由于当项目完工时，全部的计划价值都将实现（即成为挣值），所以进度偏差最终将等于零 成本偏差（Cost Variance，CV）它是测量项目成本绩效的一种指标。是某个给定时点的预算亏空或盈余量，表示为挣值与实际成本之差。CV = EV – ACCV&gt;0 盈余CV=0 基准CV&lt;0 超支项目结束时的成本偏差，就是完工预算（BAC）与实际成本之间的差值。由于成本偏差指明了实际绩效与成本支出之间的关系，所以非常重要。 进度绩效指数（Schedule Performance Index，SPI）是测量进度效率的一种指标，表示为挣值与计划价值之比。 SPI=EV/PV它反映了项目团队利用时间的效率。SPI1 提前使用SPI（SV）时还需要对关键路径上的绩效进行单独分析，以确认项目是否将比计划完成日期提前或推迟。 成本绩效指数（Cost Performance Index，CPI）是测量预算资源的成本效率的一种指标，表示为挣值与实际成本之比。CPI=EV/AC用来测量已完成工作的成本效率。CPI1 盈余 随着项目进展，项目团队可根据现有项目绩效，对完工估算（Estimate at Completion，EAC）进行预测，预测的结果可能与完工预算（BAC）存在差异。如果BAC已明显不再可行，则项目经理应考虑提出变更或采取行动纠正变差。在计算EAC时，通常用已完成工作的实际成本，加上剩余工作的完工尚需估算（Estimate to Complete，ETC）。估算假设假设将按预算单价完成ETC工作EAC = AC + (BAC - EV) = BAC + (AC - EV) 假设以当前CPI完成ETC工作EAC = BAC/CPI 完工尚需绩效指数（To-complete performance index, TCPI）是一种为了达到特定的管理目标（如BAC或EAC），剩余资源的使用必须达到的成本绩效指标。是剩余工作的成本与剩余预算之比。如果BAC已明显不再可行，则项目经理应考虑使用EAC进行TCPI计算。经过批准后，就用EAC取代BAC。基于BAC：TCPI =（BAC – EV）/（BAC – AC）基于EAC：TCPI =（BAC – EV）/（EAC – AC） 根据以上知识点举个例子 SV, CV, SPI, CPI ? EAC ? TCPI ? 假设将按预算单价完成ETC工作EAC = AC + (BAC-EV) = 1100 + (1500-900) = 1700 假设以当前CPI完成ETC工作EAC = BAC/CPI = 1500/0.82 = 1829 基于BACTCPI =（BAC – EV）/（BAC – AC） = (1500-900)/(1500-1100) = 1.5目前CPI=0.82，不太可能将CPI从0.82提升至1.5。 基于EACEAC = 1700 （假设按计划单价完成剩余工作）TCPI =（BAC – EV）/（EAC – AC） = (1500-900)/(1700-1100) = 1.0EAC = 1829 （假设按目前CPI完成剩余工作）TCPI =（BAC – EV）/（EAC – AC） = (1500-900)/(1829-1100) = 0.82]]></content>
      <categories>
        <category>软件过程管理</category>
      </categories>
      <tags>
        <tag>软件过程管理</tag>
        <tag>期末复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈设计模式]]></title>
    <url>%2F2019%2F05%2F22%2F%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式分类总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： 设计模式六大原则总原则：开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 1、单一职责原则不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 2、里氏替换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 5、迪米特法则（最少知道原则）（Demeter Principle）就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 6、合成复用原则（Composite Reuse Principle）原则是尽量首先使用合成/聚合的方式，而不是使用继承。 Java的设计模式顺序根据Head First Design Patterns 一、策略模式定义 策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立。 特点 策略模式体现了面向对象程序设计中非常重要的两个原则： 1. 封装变化的概念。 2. 编程中使用接口，而不是使用的是具体的实现类(面向接口编程)。 举例 我们就以Java中的TreeSet为例，TreeSet仅仅知道它只是接收一个Comparator这种接口类型，但是具体是哪种实现类，TreeSet并不关心，实现类在真正的传入TreeSet之前，TreeSet本身是不知道的，所以我们可以自己去实现Comparator接口，然后在实现类里面去封装好我们自己的规则（这里的规则你可以当做是算法），比如说我们要实现对一个集合的元素排序，但是到底是要升序排序还是降序排序，这个完全由我们来去控制，我们可以把这种变化的内容封装到自己的实现类中，真正运行的时候才知道具体的实现。 组成 抽象策略角色这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。 具体策略角色包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。 环境角色内部会持有一个抽象角色的引用，给客户端调用。对比来说，就是我们的TreeSet类。说明：TreeSet内部一定会有一个策略类的一个成员变量，这样做的目的在于可以当我们在去创建TreeSet对象的时候，可以接收我们向TreeSet类中传递的具体的策略类。编写步骤 定义抽象策略角色(为策略对象定义一个公共的接口) 编写具体策略角色(实际上就是实现上面定义的公共接口) 定义环境角色，内部持有一个策略类的引用案例实现一个加减乘除的功能。 定义抽象策略角色 /* 定义抽象策略角色 * 类似于Comparator接口 */ public interface Strategy{ /* * 实现了两个数可以计算 */ public int calc(int num1,int num2); } 定义具体策略角色(本例子仅仅演示，只是定义加、减两种具体策略) /* * 定义加法策略 */ public class AddStrategy implements Strategy{ /* * 实现clac方法，完成两个数的和 */ public int calc(int num1,int num2){ return num1+num2; } } /* * 定义减法策略 */ public class SubtractStrategy implements Strategy{ /* * 实现clac方法，完成两个数相减 */ public int calc(int num1,int num2){ return num1-num2; } } 环境角色 /* 环境角色 类似于TreeSet*/public class Environment{// 持有对策略类的引用private Strategy strategy; // 类似于TreeSetpublic Environment(Strategy strategy){this.strategy = strategy;} public int calulate(int a , int b){return strategy.calc(a,b);}} 测试类 /* * 测试类 */ public class Test{ public static void main(String[] args){ Environment environment = new Environment(new AddStrategy()); int result = environment.calulate(20,30); Ststem.out.println(result); } } 总结策略模式的优点： 策略模式的功能就是通过抽象、封装来定义一系列的算法，使得这些算法可以相互替换，所以为这些算法定义一个公共的接口，以约束这些算法的功能实现。如果这些算法具有公共的功能，可以将接口变为抽象类，将公共功能放到抽象父类里面。 策略模式的一系列算法是可以相互替换的、是平等的，写在一起就是if-else组织结构，如果算法实现里又有条件语句，就构成了多重条件语句，可以用策略模式，避免这样的多重条件语句。 扩展性更好：在策略模式中扩展策略实现非常的容易，只要新增一个策略实现类，然后在使用策略实现的地方，使用这个新的策略实现就好了。 策略模式的缺点： 客户端必须了解所有的策略，清楚它们的不同：如果由客户端来决定使用何种算法，那客户端必须知道所有的策略，清楚各个策略的功能和不同，这样才能做出正确的选择，但是这暴露了策略的具体实现。 增加了对象的数量：由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多。 只适合偏平的算法结构：由于策略模式的各个策略实现是平等的关系（可相互替换），实际上就构成了一个扁平的算法结构。即一个策略接口下面有多个平等的策略实现（多个策略实现是兄弟关系），并且运行时只能有一个算法被使用。这就限制了算法的使用层级，且不能被嵌套。 参考自 策略模式详解、深入解析策略模式 二、观察者（Observer）模式定义在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。 大白话其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。 结构图 组成 抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。 具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。使用场景例子有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。具体实现 定义一个抽象被观察者接口 /*** 抽象被观察者接口 声明了添加、删除、通知观察者方法 @author charming /public interface Observerable { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver(); } 定义一个抽象观察者接口 /*** 抽象观察者 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 @author charming /public interface Observer { public void update(String message);} 定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。 import java.util.ArrayList;import java.util.List; /** 被观察者，也就是微信公众号服务 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 @author charming /public class WechatServer implements Observerable { //注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程private List list;private String message; public WechatServer() { list = new ArrayList();} @Overridepublic void registerObserver(Observer o) { list.add(o);} @Overridepublic void removeObserver(Observer o) { if(!list.isEmpty()) list.remove(o); } //遍历@Overridepublic void notifyObserver() { for(int i = 0; i &lt; list.size(); i++) { Observer oserver = list.get(i); oserver.update(message); }} public void setInfomation(String s) { this.message = s; System.out.println(&quot;微信服务更新消息： &quot; + s); //消息更新，通知所有观察者 notifyObserver(); } } 定义具体观察者，微信公众号的具体观察者为用户User /** 观察者 实现了update方法 @author charming /public class User implements Observer { private String name; private String message; public User(String name) { this.name = name; } @Override public void update(String message) { this.message = message; read(); } public void read() { System.out.println(name + &quot; 收到推送消息： &quot; + message); }} 编写一个测试类 首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。 用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户还是正常能收到推送消息。 public class Test { public static void main(String[] args) { WechatServer server = new WechatServer(); Observer userZhang = new User(&quot;ZhangSan&quot;); Observer userLi = new User(&quot;LiSi&quot;); Observer userWang = new User(&quot;WangWu&quot;); server.registerObserver(userZhang); server.registerObserver(userLi); server.registerObserver(userWang); server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;); System.out.println(&quot;----------------------------------------------&quot;); server.removeObserver(userZhang); server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;); } } 测试结果 小结 这个模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影像。 JDK中也有自带的观察者模式。但是被观察者是一个类而不是接口，限制了它的复用能力。 在JavaBean和Swing中也可以看到观察者模式的影子。 三、装饰者模式12&gt; 很烦，装饰者模式没保存到，由于篇幅过长我就不再贴了，放到后面与代理模式比较吧。&gt; ##四、 工厂模式 概念 为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 类别 简单工厂模式Simple Factory：不利于产生系列产品； 工厂方法模式Factory Method：又称为多形性工厂； 抽象工厂模式Abstract Factory：又称为工具箱，产生产品族，但不利于产生新的产品； 这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。 1. 简单工厂模式简单工厂模式又称静态工厂方法模式。从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。在简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定哪一个产品类应当被实例化。 先来看看它的组成： 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 简单工厂模式又分为三种： 普通:就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口： public interface Sender { public void Send(); } 其次，创建实现类： public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } 最后，建工厂类： public class SendFactory { public Sender produce(String type) { if (&quot;mail&quot;.equals(type)) { return new MailSender(); } else if (&quot;sms&quot;.equals(type)) { return new SmsSender(); } else { System.out.println(&quot;请输入正确的类型!&quot;); return null; } } } 我们来测试下： public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produce(&quot;sms&quot;); sender.Send(); } } 输出：this is sms sender! 多个方法是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：将上面的代码做下修改，改动下SendFactory类就行，如下： public class SendFactory { public Sender produceMail(){ return new MailSender(); } public Sender produceSms(){ return new SmsSender(); } } 测试类如下： public class FactoryTest { public static void main(String[] args) { SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); } } 输出：this is mailsender! 多个静态方法将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 public class SendFactory { public static Sender produceMail(){ return new MailSender(); } public static Sender produceSms(){ return new SmsSender(); } } public class FactoryTest { public static void main(String[] args) { Sender sender = SendFactory.produceMail(); sender.Send(); } } 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 2. 工厂方法模式（Factory Method） 简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。 public interface Sender { public void Send(); } //两个实现类： public class MailSender implements Sender { @Override public void Send() { System.out.println(&quot;this is mailsender!&quot;); } } public class SmsSender implements Sender { @Override public void Send() { System.out.println(&quot;this is sms sender!&quot;); } } //工厂接口 public interface Provider { public Sender produce(); } //两个工厂类： public class SendMailFactory implements Provider { @Override public Sender produce(){ return new MailSender(); } } public class SendSmsFactory implements Provider{ @Override public Sender produce() { return new SmsSender(); } } //测试类： public class Test { public static void main(String[] args) { Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); } } 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ 3. 抽象工厂模式 为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体实现类。 例如：Q3和Q7有不同的轮胎、发动机、制动系统。虽然生产的零件不同，型号不同。但是根本上都有共同的约束，就是轮胎、发动机、制动系统。设计如下： 1. 需要一个抽象工厂，里面有三个接口分别为生产轮胎、发动机、制动系统，抽象类 2. 需要三个抽象产品分别为轮胎、发动机、制动系统，抽象接口 3. 需要实现上面的三个抽象接口，定义出每个接口不通的对象，比如：普通轮胎和越野轮胎 4. 需要两个具体类继承自上面的抽象类，实现具体的工厂，比如：生产Q3的工厂和生产Q7的工厂 5. 在客户端new出对应的具体工厂并调用对应的生产方法 //1.抽象工厂 public abstract class CarFactory { /** * 生产轮胎 * * @return 轮胎 * */ public abstract ITire createTire(); /** * 生产发动机 * * @return 发动机 * */ public abstract IEngine createEngine(); /** * 生产制动系统 * * @return 制动系统 * */ public abstract IBrake createBrake(); } //2.三个产品抽象接口 public interface ITire { /** * 轮胎 */ void tire(); } public interface IEngine { /** *发动机 */ void engine(); } public interface IBrake { /** *制动系统 */ void brake(); } //3.根据抽象接口定义不同的对象 public class NormalBrake implements IBrake{ @Override public void brake() { System.out.println(&quot;普通制动&quot;); } } public class SeniorBrake implements IBrake{ @Override public void brake() { System.out.println(&quot;高级制动&quot;); } } //后面的定义省略。。。。。。。。。。。。。 //4.实现具体的工厂类 public class Q3Factory extends CarFactory{ @Override public ITire createTire() { return new NormalTire(); } @Override public IEngine createEngine() { return new DomesticEngine(); } @Override public IBrake createBrake() { return new NormalBrake(); } } //5.客户端使用 public class Client { public static void main(String[] args) { //A车厂 CarFactory factoryQ3 = new Q3Factory(); factoryQ3.createTire().tire(); factoryQ3.createEngine().engine(); factoryQ3.createBrake().brake(); } } //输出 普通轮胎 国产发动机 普通制动 4. 工厂方法模式和抽象工厂模式区别 工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。 区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。 对于java来说，你能见到的大部分抽象工厂模式都是这样的：—它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。 比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。 这样A和B就是工厂，对应于抽象工厂；每个工厂生产的鼠标和键盘就是产品，对应于工厂方法； 用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法） 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线 五、单例模式定义 单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。 许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。 好处 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 基本的实现思路 单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。 单例的实现主要是通过以下两个步骤： 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 注意事项 单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。 单例模式的八种写法1、饿汉式（静态常量）[可用] public class Singleton { private final static Singleton INSTANCE = new Singleton(); private Singleton(){} public static Singleton getInstance(){ return INSTANCE; } } 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。 2、饿汉式（静态代码块）[可用]public class Singleton { private static Singleton instance; static { instance = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return instance; } } 这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。 ####3、懒汉式(线程不安全)[不可用] public class Singleton { private static Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。 ####4、懒汉式(线程安全，同步方法)[不推荐用] public class Singleton { private static Singleton singleton; private Singleton() {} public static synchronized Singleton getInstance() { if (singleton == null) { singleton = new Singleton(); } return singleton; } } 解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 ####5、懒汉式(线程安全，同步代码块)[不可用] public class Singleton { private static Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { singleton = new Singleton(); } } return singleton; } } 由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 ####6、双重检查[推荐用] public class Singleton { private static volatile Singleton singleton; private Singleton() {} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。 优点：线程安全；延迟加载；效率较高。 ####7、静态内部类[推荐用] public class Singleton { private Singleton() {} private static class SingletonInstance { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } } 这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 ####8、枚举[推荐用] public enum Singleton { INSTANCE; public void whateverMethod() { } } 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。 总结 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。 最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。 参考自单例模式的八种写法比较 ##六、命令模式 定义 命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations. 举例 假设某个公司需要设计一个多用功能的遥控器。基本的需求如下： 该遥控器有可以控制风扇，白炽灯，热水器等等的多对开关，而且可能还有其他的电器，暂时不做其功能，但是希望可以保留接口，用的时间可以方便的扩展。 除上面的需求之外，还需要有个按钮，可以撤销上一步的操作。基本功能如下图：在设计遥控器时，风扇，白炽灯，热水器的开关方法已经定义好，其名字各不相同。不妨设置其方法为如下： 由于各种电器的开关方法都不一样，而且还存在一个待扩展的电器，如果没有学习命名模式之前，我们在设置扩展的开关时，会出现的问题是什么呢？假设现在有电视，冰箱还可能会用到遥控器，那么我们会在最后一个开关上写if else，当然如果哪一天有多了一个大门也加入了我们的遥控的行列，这样我们继续加if else ，很显然随着电器的高速发展，会有多个需要遥控可以控制的。 举个例子，如果我们是需要遥控的客户，现在有一款遥控如果有遥控可以进行扩展，一种是可以扩展指定类型的，像上面的，只能再去扩展电视和冰箱中的一种，偶尔有一天你看到隔壁邻居的门，也可以使用遥控了，所以你去把你的高级遥控器，拿到扩展店时，扩展工程师说了，现在只能扩展电视和冰箱，不支持对大门的遥控扩展. 我们肯定是希望，可以自由的扩展，大门可以使用遥控了，就对大门扩展，车门使用遥控了，就对车门扩展……其实也就是一种松耦合的实现。 我们可以先定义好我们的风扇，白炽灯，热水器。然后定义其分别的开关命令，每个命令都有自己对应的电器引用，而且会在命令的Excute中包装电器的开或者关，最后需要把命令安装到遥控器上面，在遥控器上每个按钮都对应有自己的激发方法，其代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201namespace RemoteControl&#123; class Program &#123; static void Main(string[] args) &#123; //家中的电器 Fan fan=new Fan(); Light light=new Light(); Heater heater=new Heater(); //电器分别对应的命令 FanOffCommand fanOffCommand=new FanOffCommand(fan); FanOnCommand fanOnCommand=new FanOnCommand(fan); LightOnCommand lightOnCommand=new LightOnCommand(light); LightOffCommand lightOffCommand=new LightOffCommand(light); HeaterOnCommand heaterOnCommand=new HeaterOnCommand(heater); HeaterOffCommand heaterOffCommand=new HeaterOffCommand(heater); RemoteControl remoteControl = new RemoteControl(); //设置遥控器 remoteControl.SetCommand(0, fanOnCommand, fanOffCommand); remoteControl.SetCommand(1, lightOnCommand, lightOffCommand); remoteControl.SetCommand(2, heaterOnCommand, heaterOffCommand); //分别测试遥控器的命令 remoteControl.OnButtonWasPress(1); remoteControl.OffButtonWasPress(1); remoteControl.OnButtonWasPress(0); remoteControl.OffButtonWasPress(0); Console.ReadKey(); &#125; &#125; /// &lt;summary&gt; /// 风扇类 /// &lt;/summary&gt; public class Fan &#123; public void FanOn() &#123; Console.WriteLine(&quot;风扇开了&quot;); &#125; public void FanOff() &#123; Console.WriteLine(&quot;风扇关了&quot;); &#125; &#125; /// &lt;summary&gt; /// 灯类 /// &lt;/summary&gt; public class Light &#123; public void LightOn() &#123; Console.WriteLine(&quot;灯亮了&quot;); &#125; public void LightOff() &#123; Console.WriteLine(&quot;灯灭了&quot;); &#125; &#125; /// &lt;summary&gt; /// 热水器类 /// &lt;/summary&gt; public class Heater &#123; public void HeaterOn() &#123; Console.WriteLine(&quot;加热中&quot;); &#125; public void HeaterOff() &#123; Console.WriteLine(&quot;停止加热&quot;); &#125; &#125; /// &lt;summary&gt; /// 命令接口 /// &lt;/summary&gt; public interface ICommand &#123; void Excute(); &#125; public class FanOnCommand : ICommand &#123; Fan fan; public FanOnCommand(Fan fan) &#123; this.fan = fan; &#125; public void Excute() &#123; this.fan.FanOn(); &#125; &#125; public class FanOffCommand : ICommand &#123; Fan fan; public FanOffCommand(Fan fan) &#123; this.fan = fan; &#125; public void Excute() &#123; this.fan.FanOff(); &#125; &#125; public class LightOnCommand : ICommand &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; light.LightOn(); &#125; &#125; public class LightOffCommand : ICommand &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; this.light.LightOff(); &#125; &#125; public class HeaterOnCommand : ICommand &#123; Heater heater; public HeaterOnCommand(Heater heater) &#123; this.heater = heater; &#125; public void Excute() &#123; this.heater.HeaterOn(); &#125; &#125; public class HeaterOffCommand : ICommand &#123; Heater heater; public HeaterOffCommand(Heater heater) &#123; this.heater = heater; &#125; public void Excute() &#123; this.heater.HeaterOff(); &#125; &#125; public class NoCommand : ICommand &#123; public void Excute() &#123; &#125; &#125; public class RemoteControl &#123; private ICommand[] onCommands; private ICommand[] offCommands; public RemoteControl() &#123; ICommand noCommand=new NoCommand(); onCommands = new ICommand[4]; offCommands = new ICommand[4]; for (int i = 0; i &lt; 4; i++) &#123; onCommands[i] = noCommand; offCommands[i] = noCommand; &#125; &#125; public void SetCommand(int slot, ICommand onCommand, ICommand offCommand) &#123; onCommands[slot] = onCommand; offCommands[slot] = offCommand; &#125; public void OnButtonWasPress(int slot) &#123; onCommands[slot].Excute(); &#125; public void OffButtonWasPress(int slot) &#123; offCommands[slot].Excute(); &#125; &#125;&#125; 这样基本上就实现了我们的现有的三种电器的遥控。需要注意的是，在开始初始化遥控器时，对每个命令初始化成了NoCommand，也就是什么都不执行。在命令的初始化经常使用，同时这也解决了我们的在扩展前什么都不做的难题。看了风扇，白炽灯，热水器的遥控实现，进一步的扩展任何的电器，相信都不是什么难事。但是还有个功能没有实现，就是撤销到上一步的操作，接下来我们就来实现撤销操作。 撤销操作就想我们遥控中的返回一样。基本上就是灯亮着，突然按了一下关灯，然后再按一下返回键，灯就亮了。其他的电器同样的道理。下面先看一下灯的撤销原理，命令除了执行外还有一个撤销，所以我们需要先都命令的接口添加一个方法。 123456789101112131415161718192021222324252627282930/// &lt;summary&gt; /// 命令接口 /// &lt;/summary&gt; public interface ICommand &#123; void Excute(); void Undo(); &#125;对于开灯需要做的修改如下：public class LightOnCommand : ICommand &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; public void Excute() &#123; light.LightOn(); &#125; /// &lt;summary&gt; /// 调用命令的反命令 /// &lt;/summary&gt; public void Undo() &#123; light.LightOff(); &#125; &#125; 其他命令同理，代码会在源码中一并给出。也就是每个命令都有自己的反命令，在Undo方法里面也就是调用反命令的Excute方法。每当按下一个按钮时，就去记录其命令的名称，如果按撤销的话，就执行命名的Undo方法。下面给出主要代码：1234567891011121314public void OnButtonWasPressed(int slot) &#123; onCommands[slot].Excute(); backCommand=onCommands[slot]; &#125; public void OffButtonWasPressed(int slot) &#123; offCommands[slot].Excute(); backCommand = offCommands[slot]; &#125; public void BackButtonWasPressed() &#123; backCommand.Undo(); &#125; 以上是对遥控器对命令的撤销，需要注意两点1、通过记住命令执行之前的状态，然后去恢复到原来的状态。2、在每次执行之后要记住执行的那个命令。也即记住命令和记住状态。 除了一次执行一个命令和撤销一个命令，当然还可以一次执行多个命令。下面给出主要代码：1234567891011121314151617181920212223242526272829public class MutlipleCommand : ICommand &#123; ICommand[] commands; ICommand[] backCommands; public MutlipleCommand(ICommand[] commands) &#123; this.commands = commands; backCommands = new ICommand[commands.Length]; &#125; public void Excute() &#123; for (int i = 0; i &lt; commands.Length; i++) &#123; commands[i].Excute(); backCommands[i] = commands[i]; &#125; &#125; public void Undo() &#123; for (int i = 0; i &lt; commands.Length; i++) &#123; backCommands[i].Undo(); &#125; &#125; &#125; 总结 命令模式主要通过中介Command实现了发出命令者和命令的执行者，也即Invoke类和Receiver的松耦合。 参考自命令模式 七、适配器模式定义 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 ###1、类的适配器模式 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：1234567891011121314151617181920212223242526272829303132333435363738394041public class Source &#123; public void method1() &#123; System.out.println(&quot;this is original method!&quot;); &#125; &#125;public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2(); &#125; public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(&quot;this is the targetable method!&quot;); &#125; &#125;//Adapter类继承Source类，实现Targetable接口，下面是测试类：public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125; &#125;输出：this is original method!this is the targetable method!这样Targetable接口的实现类就具有了Source类的功能。 ###2、对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图： 只需要修改Adapter类的源码即可：1234567891011121314151617181920212223242526272829public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(&quot;this is the targetable method!&quot;); &#125; @Override public void method1() &#123; source.method1(); &#125; &#125;public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125; &#125;输出与第一种一样，只是适配的方法不同而已。 ###3、接口的适配器模式 第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：123456789101112131415161718192021222324252627282930313233343536public interface Sourceable &#123; public void method1(); public void method2(); &#125;public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; ; public void method2()&#123;&#125; ;&#125;public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;); &#125; &#125;public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;); &#125; &#125;public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125; &#125; 测试输出： the sourceable interface’s first Sub1!the sourceable interface’s second Sub2! 达到了我们的效果！ 总结 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 八、模板方法模式（略） 九、迭代器与组合模式（略） 十、状态模式（略） 十一、代理模式（极其重要）与装饰者模式的区别 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。 举个例子 例如：有婴儿，婴儿会吃饭和走动，如以下类1234567891011121314//婴儿类public class Child implements Human&#123; public void eat() &#123; System.out.println(&quot;eat something....&quot;); &#125; @Override public void run() &#123; System.out.println(&quot;Child run very slow&quot;); &#125;&#125; 突然有一天，家长发现不行，孩子不能随便吃东西，而且吃饭前一定要洗手。但是孩子太小(被委托方)，不会自己洗手。家长(Client 端)又没法照顾孩子。那简单，找个保姆照顾孩子！ 让保姆类和婴儿类共同实现同一个接口，让保姆类全程管理小孩，同时在家长眼里，只要看到保姆在帮孩子洗手就可以了。于是，有以下内容。1234567891011121314151617//保姆类public class BabySitter implements Human&#123; @Override public void eat() &#123; &#125; @Override public void run() &#123; &#125;&#125; 现在保姆已经有了，孩子也有了，怎么把孩子跟保姆关联起来。让保姆给相应的孩纸洗手。于是保姆类更改如下12345678910111213141516171819202122232425262728293031//保姆类public class BabySitter implements Human&#123; private Human human; public BabySitter(Human human) &#123; this.human = human; &#125; @Override public void eat() &#123; // 添加washHand的方法 this.washHandForChild(); human.eat(); &#125; @Override public void run() &#123; &#125; public void washHandForChild() &#123; System.out.println(&quot;help the child to wash his hands&quot;); &#125;&#125;保姆与婴儿类关联 好，那么家长就是给孩纸找了个保姆助手(装饰器)，让他附加了一些婴儿做不了事。同时家长也没有强迫孩纸自己学会洗手(不更改Child类)1234567891011//客户端public class Client&#123; public static void main(String[] args) &#123; Human human = new BabySitter(new Child()); human.eat(); &#125;&#125;家长客户端代码 以上就是一个简单的装饰模式，来看一下这一块完整的类图。 装饰模式的一个很重要特点就是，在客户端可以看到抽象对象的实例，如Human human = new BabySitter(new Child()); 因为装饰模式通过聚合方式，把内容整合到装饰类里面了。 装饰者模式能够使用装饰类对抽象对象进行装饰。假如来了个OldMan类手脚不利索。保姆类BabySitter同样能够胜任这个OldMan的饭前洗手操作。 代理模式类图如下： 由该类图可知，以上BabySitter代码应该如下：123456789101112131415161718192021222324252627282930313233343536373839//保姆类public class BabySitter implements Human&#123; private Child child; public BabySitter() &#123; child = new Child(); &#125; @Override public void eat() &#123; // 添加washHand的方法 this.washHandForChild(); human.eat(); &#125; @Override public void run() &#123; &#125; public void washHandForChild() &#123; System.out.println(&quot;help the child to wash his hands&quot;); &#125;&#125;//客户端public class Client&#123; public static void main(String[] args) &#123; Human human = new BabySitter(); human.eat(); &#125;&#125; 装饰者模式和代理模式的最后运行的结果都是一样的，由代理模式代码可知，客户端不关心代理类了哪个类。但代码控制了客户端对委托类的访问。客户端代码表现为 Human human = new BabySitter( ); 所以资料上都说了，装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制。两者都一样拥有抽象角色（接口）、真实角色（委托类）、代理类 。 由于代理类实现了抽象角色的接口，导致代理类无法通用。如有天，一个有钱人养了只小猩猩，他要一个保姆在猩猩吃东西前，帮猩猩洗手….保姆根本不懂猩猩的特性（跟猩猩类不是同一类型的，保姆属于Human类，而猩猩可能属于Animal类型。），但洗手这个方法是不变的，用水洗。能不能找一个代理说既可以照看人吃饭前洗手也可以照看猩猩吃饭前洗手？ 要实现这种功能，必须让代理类与特定的接口分离。在代理的时候能够了解每个委托的特性，这就有可能了。这时候动态代理就出现了。 动态代理关于动态代理模式里面有两种实现，一种是jdk实现，一种是cglib来实现。下面来整jdk来实现动态代理的Java实例。jdk动态代理模式里面有个拦截器的概念，在jdk中，只要实现了InvocationHandler这个接口的类就是一个拦截器类。还使用了些反射的相关概念。拦截器的概念不了解没关系，假如写了个请求到action，经过拦截器，然后才会到action。然后继续有之后的操作。拦截器就像一个过滤网，一层层的过滤，只要满足一定条件，才能继续向后执行。拦截器的作用：控制目标对象的目标方法的执行。 拦截器的具体操作步骤：1.引入类：目标类和一些扩展方法相关的类。2.赋值：调用构造函数给相关对象赋值3.合并逻辑处理：在invoke方法中把所有的逻辑结合在一起。最终决定目标方法是否被调用。 总结 动态代理静态代理的区别，代理涉及到两个关联词代理类和委托类。静态代理一个代理类针对一个委托类！动态代理一个代理类可利用反射机制代理多个委托类 我们根据加载被代理类的时机不同，将代理分为静态代理和动态代理。如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，比如RPC框架和Spring AOP机制。 参考自代理模式和装饰模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十三)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%B8%89%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下UDP和TCP的对比. UDP和TCP在TCP/IP体系中的位置 UDP和TCP的对比 UDP和TCP的对比–是否面向连接 UDP和TCP的对比–是否支持广播和多播 UDP和TCP的对比–对应用层报文的处理 UDP和TCP的对比–是否提供可靠传输服务 UDP和TCP的对比–首部开销 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十二)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下TCP/IP体系运输层的端口号. 运输层协议和网际层协议的作用范围 从体系结构的角度看进程之间的通信 基于端口的复用和分用 TCP/IP运输层端口号 举点端口号的例子 常用的熟知端口(了解) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十一)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%E4%B8%80%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下网际控制报文协议ICMP,仅记忆几张图即可. 网际控制报文协议ICMP 四种常见的ICMP差错报告报文 两种ICMP询问报文 ICMP的应用举例 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(十)]]></title>
    <url>%2F2019%2F04%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%8D%81%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下IPv4数据报的首部. 数据包的逐层封装 接下来的内容涵盖在IP首部中 IPv4数据报首部格式 版本 首部长度 区分服务 总长度 讲到首部长度和总长度我们来看一个例子吧,Tips:首部长度以4字节为单位 由于IPv4数据报长度有限,有时需要分片，这时就需要标识,标志，片偏移字段了 标识 (不同主机可能发送的标识相同,需结合源IP地址加以区分) 片偏移 标志 IPv4数据报分片举例 生存时间 协议 首部校验和 源IP地址和目的IP地址 可选字段(长度可变) 填充 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(九)]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B9%9D%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦这一篇是硬骨头!!! 本小章整合了挺多内容,包括了路由信息协议RIP,开放最短路径优先OSPF,边界网关协议BGP. 路由选择协议–概述 静态路由选择和动态路由选择 静态路由选择 由人工配置的特定主机路由,网络路由,默认路由,黑洞路由等都属于静态路由. 这种人工配置方式简单,开销小.但不能及时适应网络状态(流量,拓扑等)的变化. 一般只在小规模网络中采用. 动态路由选择 路由器通过路由选择协议自动获取路由信息. 比较复杂,开销比较大.能较好地适应网络状态的变化. 适用于大规模网络. 互联网所采用的路由选择协议的特点 自适应动态路由选择,能较好地适应网络状态的变化 分布式路由器之间交换路由信息 分层次将整个互联网划分为许多较小的自治系统AS(autonomous system) 互联网所采用的分层次的路由选择协议 常见的路由选择协议 路由器的结构 路由选择协议–路由信息协议RIP 路由信息协议RIP(Routing Information Protocol)是最早得到广泛使用的内部网关协议IGP. RIP是一种基于距离矢量D-V(Distance-Vector)算法的协议,它使用跳数(Hop Count)作为度量(Metric)来衡量到达目的网络的距离. 默认情况下,路由器到与它直接相连网络的跳数为0,因此距离为0. 路由器到与它非直连网络的距离等于中间所经过路由器的数量. 举例的取值范围是0~15,等于或大于16的距离被定义为无穷大,即目的网络不可达. RIP认为到达目的网络距离最小的路由才是好路由 等价负载均衡 思科Cisco早期的RIP支持最大6条等价负载均衡(默认支持4条) RIP的基本工作原理 更新定时器:30s 失效定时器:180s 清除定时器:240s RIP的路由条目更新规则举个例子 RIP减少路由环路产生以及加快收敛速度的方法 RIP无法完全避免路由环路因为某路由器连接的一网络故障后,则把该条目距离写成16,并向邻居路由器发送RIP更新,而某邻居路由器可能丢包. 路由选择协议–开放最短路径优先OSPF 链路状态 邻居关系的建立和维护 链路状态通告LSA(Link State Advertisement) 链路状态更新LSU(Link State Update) 链路状态数据库LSDB(Link State DataBase) 基于LSDB进行SPF计算 OSPF的五种分组类型及其作用 多路访问网络中路由器邻居关系的建立 OSPF划分为两种不同的区域 OSPF与RIP的对比 路由选择协议–边际网关协议BGP IGP与EGP对比 BGP根据策略寻找较好的路由(不兜圈子) BGP适用于多级结构的互联网 BGP-4的四种报文 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(八)]]></title>
    <url>%2F2019%2F04%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%85%AB%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下默认路由和特定主机路由以及静态路由的路由环路问题. 默认路由和特定主机路由 特定主机路由,网络路由,默认路由 若有多条路由记录匹配,则”最长前缀匹配”,这样的路由更具体(也可认为更精确) 静态路由的路由环路问题 配置错误 聚合了不存在的网络 网络故障 配置错误导致路由环路由于路由表中有些条目手工添加,添加错误可能出现环路. 为了避免上述情况发生时IP数据报永无休止地转发下去, IP数据报首部有TTL生存字段,最大值为255,当路由器接收 数据报后将TTL减一,若TTL等于0则丢弃 聚合了不存在的网络而导致路由环路 上面可以解释为: 在路由表中由192.168.1.0/24和192.168.2.0/24聚合成一个网络192.168.0.0/22， 而192.168.0.0/22又包含了不存在的192.168.3.0/24和192.168.0.0/24, 若主机发送数据报给不存在的网络,路由器找不到路由记录时会走默认路由,而默认路由恰好 往回走则会出现环路问题. 解决方法:为不存在的网络地址添加黑洞路由,下一跳为null0 网络故障导致路由环路 这个也很好理解,主机发送给目的主机之间某条链路故障,路由表抹去了记录,路由器找不到记录只能走默认路由,和上述一样. (也可以添加对应的黑洞路由,当记录被抹去,则黑洞路由条目自动生效) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转发和重定向的区别]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%BD%AC%E5%8F%91%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[转发和重定向区别详解作为一名程序员，特别是java web开发的程序员，在使用servlet/jsp的时候，我们必须要知道实现页面跳转的两种方式的区别和联系：即转发和重定向的区别。 RequestDispatcher.forward方法只能将请求转发给同一个WEB应用中的组件；而HttpServletResponse.sendRedirect 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源。如果传递给HttpServletResponse.sendRedirect 方法的相对URL以“/”开头，它是相对于整个WEB站点的根目录；如果创建RequestDispatcher对象时指定的相对URL以“/”开头，它是相对于当前WEB应用程序的根目录。 调用HttpServletResponse.sendRedirect方法重定向的访问过程结束后，浏览器地址栏中显示的URL会发生改变，由初始的URL地址变成重定向的目标URL；而调用RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址不变。 HttpServletResponse.sendRedirect方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的 访问请求，这个过程好比有个绰号叫“浏览器”的人写信找张三借钱，张三回信说没有钱，让“浏览器”去找李四借，并将李四现在的通信地址告诉给了“浏览器”。于是，“浏览器”又按张三提供通信地址给李四写信借钱，李四收到信后就把钱汇给了“浏览器”。可见，“浏览器”一共发出了两封信和收到了两次回复， “浏览器”也知道他借到的钱出自李四之手。RequestDispatcher.forward方法在服务器端内部将请求转发给另外一个资源，浏览器只知道发出了请求并得到了响应结果，并不知道在服务器程序内部发生了转发行为。这个过程好比绰号叫“浏览器”的人写信找张三借钱，张三没有钱，于是张三找李四借了一些钱，甚至还可以加上自己的一些钱，然后再将这些钱汇给了“浏览器”。可见，“浏览器”只发 出了一封信和收到了一次回复，他只知道从张三那里借到了钱，并不知道有一部分钱出自李四之手。 RequestDispatcher.forward方法的调用者与被调用者之间共享相同的request对象和response对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect方法调用者与被调用者使用各自的request对象和response对象，它们属于两个独立的访问请求和响应过程。对于同一个WEB应用程序的内部资源之间的跳转，特别是跳转之前要对请求进行一些前期预处理，并要使用HttpServletRequest.setAttribute方法传递预处理结果，那就应该使用RequestDispatcher.forward方法。不同WEB应用程序之间的重定向，特别是要重定向到另外一个WEB站点上的资源的情况，都应该使用HttpServletResponse.sendRedirect方法。 无论是RequestDispatcher.forward方法，还是HttpServletResponse.sendRedirect方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中。 两种跳转获得对象的方式123456//获得转发对象getRequestDispatcher()HttpServletRequest(httpServletRequest).getRequestDispatcherServletContext.getRequestDispatcher(); //获得重定向对象sendRedirect()HttpServletResponse(httpServletResponse).sendRedirect(); 转发和跳转的小结 转发使用的是getRequestDispatcher()方法;重定向使用的是sendRedirect(); 转发：浏览器URL的地址栏不变。重定向：浏览器URL的地址栏改变； 转发是服务器行为，重定向是客户端行为； 转发是浏览器只做了一次访问请求。重定向是浏览器做了至少两次的访问请求； 转发2次跳转之间传输的信息不会丢失，重定向2次跳转之间传输的信息会丢失（request范围）。 转发和重定向的选择 重定向的速度比转发慢，因为浏览器还得发出一个新的请求，如果在使用转发和重定向都无所谓的时候建议使用转发。 因为转发只能访问当前WEB的应用程序，所以不同WEB应用程序之间的访问，特别是要访问到另外一个WEB站点上的资源的情况，这个时候就只能使用重定向了。 转发和重定向的应用场景在上面我已经提到了，转发是要比重定向快，因为重定向需要经过客户端，而转发没有。有时候，采用重定向会更好，若需要重定向到另外一个外部网站，则无法使用转发。另外，重定向还有一个应用场景：避免在用户重新加载页面时两次调用相同的动作。 例如，当提交产品表单的时候，执行保存的方法将会被调用，并执行相应的动作；这在一个真实的应用程序中，很有可能将表单中的所有产品信息加入到数据库中。但是如果在提交表单后，重新加载页面，执行保存的方法就很有可能再次被调用。同样的产品信息就将可能再次被添加，为了避免这种情况，提交表单后，你可以将用户重定向到一个不同的页面，这样的话，这个网页任意重新加载都没有副作用； 但是，使用重定向不太方便的地方是，使用它无法将值轻松地传递给目标页面。而采用转发，则可以简单地将属性添加到Model,使得目标视图可以轻松访问。由于重定向经过客户端，所以Model中的一切都会在重定向时丢失。但幸运的是，在Spring3.1版本以后，我们可以通过Flash属性，解决重定向时传值丢失的问题。 要使用Flash属性，必须在Spring MVC的配置文件中添加一个。然后，还必须再方法上添加一个新的参数类型：org.springframework.web.servlet.mvc.support.RedirectAttributes。 如下所示：123456789101112@RequestMapping(value="saveProduct",method=RequestMethod.POST)public String saveProduct(ProductForm productForm,RedirectAttributes redirectAttributes)&#123; //执行产品保存的业务逻辑等 //传递参数 redirectAttributes.addFlashAttribute("message","The product is saved successfully"); //执行重定向 return "redirect:/……";&#125; 参考自： 作者：liubin5620 来源：CSDN 原文：https://blog.csdn.net/liubin5620/article/details/79922692 版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>后端小知识</category>
      </categories>
      <tags>
        <tag>页面跳转</tag>
        <tag>Web开发</tag>
        <tag>转发</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(七)]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B8%83%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章介绍一下IP数据报的发送和转发过程(主机发送,路由器转发). 主机发送IP数据报的过程 路由器转发IP数据报的过程 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(六)]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%85%AD%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦友情提示:今天是难啃的硬骨头，一分钟怕是不行 本小章隆重介绍一下IPv4地址,包括了分类地址,划分子网,构造超网以及定长和变长子网掩码. IPv4地址 IPv4地址就是给Internet上的每一个主机或路由器的每一个接口分配一个在全世界范围是唯一的32比特的标识符 IP地址由互联网名字和数字分配机构ICANN进行分配. 2011年2月3日,互联网号码分配管理局IANA宣布,IPv4地址已经分配完毕. 我国在2014至2015年也逐步停止了向新用户和应用分配IPv4地址,同时全面开展商用部署IPv6. IPv4地址的编址方法经历了三个历史阶段: IPv4地址的点分十进制表示方法 IPv4地址-分类地址 A类地址 B类地址 C类地址 分类地址的小结 IPv4地址-划分子网 划分子网的基本思想 子网掩码 默认的子网掩码 C类网可使用的子网掩码 B类网可使用的子网掩码 A类网可使用的子网掩码 C类网络快速划分子网示例 将网络号省略后便于观察 B类网络快速划分子网示例 只有一个字节的主机号不为0 两个字节的主机号都不为0 A类网络快速划分子网示例 只有一个字节的主机号不为0 有两个字节的主机号不为0 三个字节的主机号都不为0 划分子网的小结 IPv4地址-构造超网1234不知不觉讲到第三阶段了,在讲之前我们回头看看区别吧 *分类地址阶段的IP地址由&#123;网络号，主机号&#125;组成 *划分子网阶段的IP地址由&#123;网络号,子网号,主机号&#125;组成 *而构造超网阶段的IP地址由&#123;网络前缀,主机号&#125;组成 补充一些知识以便理解后面内容 无分类域间路由选择CIDR(Classes Inter-Domain Routing) CIDR消除了传统的A类、B类和C类地址以及子网划分的概念. 路由聚合(构造超网) 构造超网(无分类编址) CIDR使用”斜线记法”,或称CIDR记法,即在IPv4地址后面加上斜线”/“,在斜线后面写上网络前缀所占的比特数量. CIDR实际上是将网络前缀都相同的连续的IP地址组成一个“CIDR地址块” 我们只要知道CIDR地址块中的任何一个地址,就可以回答以下五个问题: 地址块的最小地址 地址块的最大地址 地址块中的地址数量 地址块聚合某类(A,B,C类)网络的数量 地址掩码(也可以继续称为子网掩码) 下面举几个小例子加强理解吧例一: 例二: 例三: 定长的子网掩码和变长的子网掩码 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(五)]]></title>
    <url>%2F2019%2F04%2F13%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章简单介绍一下虚拟局域网VLAN 虚拟局域网出现背景扩展以太网的同时也扩大了广播域 交换机是数据链路层的连接设备. 使用一个或多个交换机互联起来的交换式以太网,其所有站点都属于同一个广播域. 随着交换式以太网规模的扩大,广播域相应扩大. 巨大的广播域并不是一件好事,它会带来很多问题: 产生广播风暴 难以管理和维护 潜在的安全问题 网络中会频繁出现广播信息 使用TCP/IP协议栈时,很多协议都会使用广播(重要) ARP: 地址请求协议,(已知IP地址,找出其相应的MAC地址) RIP: 路由信息协议(一种小型的,内部路由协议) DHCP: 动态主机配置协议(用于自动配置IP地址) NetBEUI: Windows下使用的广播型协议(了解) IPX/SPX: Novell网络的协议栈(了解) AppleTalk: Apple公司的网络协议栈(了解) 如何分割广播域？ 使用路由器可以隔离广播域 路由器的成本较高 虚拟局域网VLAN技术应运而生 虚拟局域网VLAN 虚拟局域网VLAN(Virtual Local Area Network) 是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术, 这些逻辑组具有某些共同的需求. 例如 如何实现VLAN? 交换机上生成的各VLAN(逻辑组)是互不相通的. 实现VLAN间通信的方法: 使用路由器 使用三层交换机 VLAN的实现机制主要实现以下两部分内容功能,这里简单介绍不展开详细讲 (1) IEEE 802.1Q帧: 在以太网的原地址字段和类型字段之间插入4字节的VLAN标记(tag)字段,俗称”打标签” (2) 交换机的端口类型: Access Trunk Hybrid(华为私有) 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(四)]]></title>
    <url>%2F2019%2F04%2F12%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦这篇例外呢，难度挺大的，想着分两篇发，但还是一鼓作气吧，吃得苦中苦 本小章简单介绍一下集线器和交换机的区别， 以及交换机的内部工作原理(重点). 集线器和交换机的区别 以太网交换机的自学习算法以太网交换机的转发原理 交换机工作在数据链路层(也包括物理层) 交换机收到数据帧后，根据帧的目的MAC地址和交换机内部的帧交换表对帧进行处理. 明确的转发:交换机知道应当从哪个/哪些接口转发该帧(单播，多播，广播). 盲目的转发:交换机不知道应当从哪个端口转发帧,只能将其通过除进入交换机的接口外的其他所有接口转发(也称为泛洪). 明确的丢弃:交换机知道不应该转发该帧，将其丢弃. 交换机是一种即插即用设备,其内部的帧交换表是通过自学习算法自动地逐渐建立起来的. 登记MAC地址与接口号:提取帧的源mac地址,将其与该帧进入本交换机接口的接口号一起作为一个条目写入交换机的帧交换表 转发帧根据帧的目的MAC地址和交换机内部的帧交换表对帧进行处理(明确转发,盲目转发,丢弃). 帧交换表中每个条目都有自己的有效时间,到期删除:原因:12交换机的接口更换另一台主机主机更换网络适配器(网卡) 交换机的生成树协议STP-功能介绍 STP出现的背景在实际的网络拓扑中,我们会添加冗余链路以提高网络可靠性, 使得某段网络链路出现故障时整个网络仍可通信, 但增加冗余链路形成了网络环路, 网络环路所带来的问题： 1. 广播风暴(大量消耗网络资源，使得网络无法正常转发其他数据帧) 2. 主机收到重复的广播帧 3. 交换机的帧交换表震荡(漂移) 使用生成树协议STP解决网络环路问题以太网交换机使用生成树协议STP(Spanning Tree Protocol), 可以在提高网络可靠性的同时又避免网络环路带来的各种问题. 1. 不论交换机之间采用怎样的物理连接,交换机都能够自动计算并构建一个 逻辑上没有环路的网络,其逻辑拓扑结构必须是树型的(无逻辑环路). 2. 最终生成的树型逻辑拓扑要确保联通整个网络的每一个部分. 3. 当首次连接交换机或网络物理拓扑发生变化时(有可能是认为改变或故障), 交换机都将进行生成树的重新计算. 生成树算法STA生成树算法STA(Spanning Tree Algorithm)是生成树协议STP的核心. 它的实现目标是: 在包含有物理环路的网络中,构建出一个能够连通全网各节点的树型无环逻辑拓扑. 生成树算法的三个步骤: 1. &quot;选举&quot;根交换机 2. &quot;选举&quot;根端口 3. &quot;选举&quot;制定端口并阻塞备用端口 注意 “选举”根交换机 “选举”根端口 “选举”制定端口并阻塞备用端口 大致了解一下步骤吧以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(三)]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 本小章简单介绍一下MAC地址，IP地址，以及ARP协议 计算机网络的寻址问题MAC地址MAC地址的作用 MAC地址的格式 标准表示法：XX-XX-XX-XX-XX-XX 例如，在Windows下00-0C-CF-93-8C-92 其他表示法：1.XX:XX:XX:XX:XX:XX 例如，在Linux,ios,Android下 00:0C:CF:93:8C:92 2.XXXX.XXXX.XXXX 例如，在Cisco Packet Tracer下000C.CF93.8C92 MAC地址的发送顺序12345字节发送顺序： 第一字节 → 第六字节字节内的比特发送顺序： b0 → b7 IP地址IP地址的作用 IP地址是互联网上各主机使用的地址，标识两部分信息：网络编号： 标识互联网上数以百万的网络 主机编号： 标识同意网络上不同的主机 很显然，之前介绍的MAC地址不具有这样的功能。12如果只是一个单独的网络，不连入互联网，可以只使用MAC地址。如果主机所在的网络连入互联网，则IP地址和MAC地址都使用。 从五层体系结构看IP地址与MAC地址 下面我们用一张图来看看数据包转发过程中IP地址与MAC地址的变化情况 具体的文字描述(可以加深理解转发过程) IP地址与MAC地址的关系 地址解析协议ARP1.在ARP高速缓存表中查找目的IP地址对应的MAC地址(因为在数据链路层需要封装该信息，如找不到则跳到第二步)2.广播发送ARP请求3.单播发送ARP响应4.ARP高速缓存表的更新(动态条目和静态条目)5.ARP作用范围：一段链路或同一网络内 补充一下内容吧,CSMA/CD协议没必要另写一章咯12345CSMA/CD曾经用于各种总线结构以太网和双绞线以太网的早起版本中.现在的以太网基于交换机和全双工连接，不会有碰撞，因此没必要使用CSMA/CD. CSMA/CD协议 其实不是很重要，初略记记英文单词就够了 载波监听多点接入/碰撞检测 Carrier Sense Multiple Access with Collision Detection 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(二)]]></title>
    <url>%2F2019%2F04%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 计算机网络体系结构中的专用术语实体1任何可发送或接受信息的硬件或软件进程 对等实体1收发双方相同层次中的实体 协议1控制两个对等实体进行逻辑通信的规则的集合 协议的三要素 语法：定义所交换信息的格式 数据链路层帧格式举例：PPP帧，以太网MAC帧，802.11局域网数据帧 网络层数据包格式举例：IP数据报，ARP，ICMP，RIP，OSPF，BGP报文 运输层数据包格式举例：UDP用户数据报，TCP报文段 语义：定义收发双方所要完成的操作 同步：定义收发双方的时序关系 服务12在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下面一层提供的服务。 服务访问点1在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型 例如: 链路层的服务访问点为帧的“类型”字段 网络层的服务访问点为IP数据报首部中的“协议”字段 运输层的服务访问点为端口号 服务原语1上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语 协议数据单元PDU1对等层次之间传送的数据包称为该层的协议数据单元 服务数据单元SDU1同一系统内，层与层之间交换的数据包称为服务数据单元 TCP/IP的四层体系结构 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识巩固(一)]]></title>
    <url>%2F2019%2F04%2F09%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E5%B7%A9%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[每天花一分钟看一篇就够啦 计算机网络体系结构概述将实现互联网所面临的主要问题划分层次： 通过应用进程间的交互来完成特定网络应用 &emsp;&emsp;&emsp;应用层（DNS,DHCP,HTTP,SMTP,TELNET,FTP,P2P） 主机间的进程通信 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运输层1.将来自网络的数据包交给哪个应用进程(端口号)2.可靠传输服务和不可靠传输服务 数据包如何从原网络传到目的网络 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;网络层1.对各网络的标识(IP地址的网络号部分)2.数据包的路由(路由器的路由选择协议和转发机制) 数据包如何在一段链路上传输 &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;数据链路层1.对主机和路由器的网络接口的标识(MAC地址)2.广播信道和点对点信道3.差错检测和可靠传输 主机，路由器等网络设备如何接入网络 &emsp;&emsp;&emsp;&emsp;&emsp;物理层1.使用何种的新号标识比特0和1(新号的调制和编码)2.使用何种物理接口(机械尺寸，引脚数量和排列) 分层思想 &emsp;OSI/RM体系结构 &emsp; &emsp;TCP/IP体系结构 &emsp; 五层协议体系结构 &emsp; 7 &emsp;&emsp;应用层 &emsp; 4 &emsp;应用层 &emsp; 5 &emsp;应用层 &emsp; &emsp; 6 &emsp;&emsp;表示层 &emsp; (HTTP,FTP,SMTP等) &emsp; &emsp; &emsp; &emsp; 5 &emsp;&emsp;会话层 &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; 4 &emsp;&emsp;运输层 &emsp; 3 &emsp;运输层(TCP或UDP) &emsp; 4 &emsp;运输层 &emsp; &emsp; 3 &emsp;&emsp;网络层 &emsp; 2 &emsp;网际层IP &emsp; 3 &emsp;网络层 &emsp; &emsp; &emsp;2 &emsp;数据链路层 &emsp; &emsp;1 &emsp;网络接口层 &emsp; &emsp;&emsp;2 &emsp;数据链路层 &emsp; &emsp; 1 &emsp;&emsp;物理层 &emsp; &emsp; &emsp; 1 &emsp;物理层 &emsp; 以上知识源于B站点击此处跳转]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>B站视频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[My First Day In Github Pages]]></title>
    <url>%2F2019%2F03%2F31%2FMy-First-Day-In-Github-Pages%2F</url>
    <content type="text"></content>
      <categories>
        <category>essay[随笔]</category>
      </categories>
      <tags>
        <tag>入门</tag>
      </tags>
  </entry>
</search>
