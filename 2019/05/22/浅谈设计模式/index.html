<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">







  <meta name="google-site-verification" content="m4MF0Cp7gp36G1gUU6YQ-szMDn64TU8hoQtLymktEPg">















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/c32.ico?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/c.ico?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">






















<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":24,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于各种常见设计模式的介绍">
<meta name="keywords" content="设计模式">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈设计模式">
<meta property="og:url" content="https://charming-victim.github.io/2019/05/22/浅谈设计模式/index.html">
<meta property="og:site_name" content="charmingBlog">
<meta property="og:description" content="关于各种常见设计模式的介绍">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://charming-victim.github.io/images/avatar.jpeg">
<meta property="og:updated_time" content="2019-05-22T01:56:53.629Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈设计模式">
<meta name="twitter:description" content="关于各种常见设计模式的介绍">
<meta name="twitter:image" content="https://charming-victim.github.io/images/avatar.jpeg">





  
  
  <link rel="canonical" href="https://charming-victim.github.io/2019/05/22/浅谈设计模式/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>浅谈设计模式 | charmingBlog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/Charming-Victim" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">charmingBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-resource">

    
    
    
      
    

    

    <a href="/Resource/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i> <br>Resource</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-calendar">

    
    
    
      
    

    

    <a href="/Calendar/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>Calendar</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>Sitemap</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Search</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://charming-victim.github.io/2019/05/22/浅谈设计模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CuiHongMing">
      <meta itemprop="description" content="爱好运动的码农">
      <meta itemprop="image" content="/images/kobe.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="charmingBlog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">浅谈设计模式

              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-22 09:49:38 / Modified: 09:56:53" itemprop="dateCreated datePublished" datetime="2019-05-22T09:49:38+08:00">2019-05-22</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/设计模式/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Symbols count in article: </span>
                
                <span title="Symbols count in article">34k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">31 mins.</span>
              
            </div>
          

          
            <div class="post-description">关于各种常见设计模式的介绍</div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <img src="/images/avatar.jpeg" itemprop="contentUrl">
            
          

          
          </div>
        </div>
      

      
        <h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><p>总体来说设计模式分为三大类：</p>
<p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p>
<p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p>
<p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<p>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：<br><img src="https://upload-images.jianshu.io/upload_images/15186378-0f4c407718ea813e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p>
<h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><h2 id="总原则：开闭原则（Open-Close-Principle）"><a href="#总原则：开闭原则（Open-Close-Principle）" class="headerlink" title="总原则：开闭原则（Open Close Principle）"></a>总原则：开闭原则（Open Close Principle）</h2><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p>
<h2 id="2、里氏替换原则（Liskov-Substitution-Principle）"><a href="#2、里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2、里氏替换原则（Liskov Substitution Principle）"></a>2、里氏替换原则（Liskov Substitution Principle）</h2><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p>
<p>历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<h2 id="3、依赖倒转原则（Dependence-Inversion-Principle）"><a href="#3、依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="3、依赖倒转原则（Dependence Inversion Principle）"></a>3、依赖倒转原则（Dependence Inversion Principle）</h2><p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<h2 id="4、接口隔离原则（Interface-Segregation-Principle）"><a href="#4、接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4、接口隔离原则（Interface Segregation Principle）"></a>4、接口隔离原则（Interface Segregation Principle）</h2><p>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<h2 id="5、迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5、迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5、迪米特法则（最少知道原则）（Demeter Principle）"></a>5、迪米特法则（最少知道原则）（Demeter Principle）</h2><p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<h2 id="6、合成复用原则（Composite-Reuse-Principle）"><a href="#6、合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h2><p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="Java的设计模式"><a href="#Java的设计模式" class="headerlink" title="Java的设计模式"></a>Java的设计模式</h1><p><code>顺序根据Head First Design Patterns</code></p>
<blockquote>
<h2 id="一、策略模式"><a href="#一、策略模式" class="headerlink" title="一、策略模式"></a>一、策略模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>   策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>   策略模式体现了面向对象程序设计中非常重要的两个原则：</p>
<pre><code>1. 封装变化的概念。
2. 编程中使用接口，而不是使用的是具体的实现类(面向接口编程)。
</code></pre><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>   我们就以Java中的TreeSet为例，TreeSet仅仅知道它只是接收一个Comparator这种接口类型，但是具体是哪种实现类，TreeSet并不关心，实现类在真正的传入TreeSet之前，TreeSet本身是不知道的，所以我们可以自己去实现Comparator接口，然后在实现类里面去封装好我们自己的规则（这里的规则你可以当做是算法），比如说我们要实现对一个集合的元素排序，但是到底是要升序排序还是降序排序，这个完全由我们来去控制，我们可以把这种变化的内容封装到自己的实现类中，真正运行的时候才知道具体的实现。</p>
<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ol>
<li>抽象策略角色这个是一个抽象的角色，通常情况下使用接口或者抽象类去实现。对比来说，就是我们的Comparator接口。</li>
<li>具体策略角色包装了具体的算法和行为。对比来说，就是实现了Comparator接口的实现一组实现类。</li>
<li>环境角色内部会持有一个抽象角色的引用，给客户端调用。对比来说，就是我们的TreeSet类。说明：TreeSet内部一定会有一个策略类的一个成员变量，这样做的目的在于可以当我们在去创建TreeSet对象的时候，可以接收我们向TreeSet类中传递的具体的策略类。<h3 id="编写步骤"><a href="#编写步骤" class="headerlink" title="编写步骤"></a>编写步骤</h3></li>
<li>定义抽象策略角色(为策略对象定义一个公共的接口)</li>
<li>编写具体策略角色(实际上就是实现上面定义的公共接口)</li>
<li>定义环境角色，内部持有一个策略类的引用<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3>实现一个加减乘除的功能。</li>
<li><p>定义抽象策略角色</p>
<pre><code>/*    定义抽象策略角色
 *    类似于Comparator接口
 */
public interface Strategy{
      /*
       *  实现了两个数可以计算
       */
       public int calc(int num1,int num2);
}
</code></pre></li>
<li><p>定义具体策略角色(本例子仅仅演示，只是定义加、减两种具体策略)</p>
<pre><code>/*    
 *    定义加法策略
 */
public class AddStrategy implements Strategy{
      /*
       *  实现clac方法，完成两个数的和
       */
       public int calc(int num1,int num2){
             return num1+num2;
       }
}

/*    
 *    定义减法策略
 */
public class SubtractStrategy implements Strategy{
      /*
       *  实现clac方法，完成两个数相减
       */
       public int calc(int num1,int num2){
             return num1-num2;
       }
}
</code></pre><ol start="3">
<li>环境角色</li>
</ol>
<p>/*</p>
<ul>
<li>环境角色</li>
<li><p>类似于TreeSet<br>*/<br>public class Environment{<br>// 持有对策略类的引用<br>private Strategy strategy;</p>
<p>// 类似于TreeSet<br>public Environment(Strategy strategy){<br>this.strategy = strategy;<br>}</p>
<p>public int calulate(int a , int b){<br>return strategy.calc(a,b);<br>}<br>}</p>
</li>
</ul>
</li>
<li><p>测试类</p>
<pre><code>/*
 *    测试类
 */
 public class Test{
       public static void main(String[] args){
           Environment environment = new Environment(new AddStrategy());
           int result = environment.calulate(20,30);
           Ststem.out.println(result);
       }
 }
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>策略模式的优点：</p>
</li>
<li><p>策略模式的功能就是通过抽象、封装来定义一系列的算法，使得这些算法可以相互替换，所以为这些算法定义一个公共的接口，以约束这些算法的功能实现。如果这些算法具有公共的功能，可以将接口变为抽象类，将公共功能放到抽象父类里面。</p>
</li>
<li><p>策略模式的一系列算法是可以相互替换的、是平等的，写在一起就是if-else组织结构，如果算法实现里又有条件语句，就构成了多重条件语句，可以用策略模式，避免这样的多重条件语句。</p>
</li>
<li><p>扩展性更好：在策略模式中扩展策略实现非常的容易，只要新增一个策略实现类，然后在使用策略实现的地方，使用这个新的策略实现就好了。</p>
<p>策略模式的缺点：</p>
<ol>
<li><p>客户端必须了解所有的策略，清楚它们的不同：<br>如果由客户端来决定使用何种算法，那客户端必须知道所有的策略，清楚各个策略的功能和不同，这样才能做出正确的选择，但是这暴露了策略的具体实现。</p>
</li>
<li><p>增加了对象的数量：<br>由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多。</p>
</li>
<li><p>只适合偏平的算法结构：<br>由于策略模式的各个策略实现是平等的关系（可相互替换），实际上就构成了一个扁平的算法结构。即一个策略接口下面有多个平等的策略实现（多个策略实现是兄弟关系），并且运行时只能有一个算法被使用。这就限制了算法的使用层级，且不能被嵌套。</p>
</li>
</ol>
</li>
</ol>
</blockquote>
<p>参考自    <a href="http://baijiahao.baidu.com/s?id=1601547440739500969&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">策略模式详解</a>、<a href="https://www.cnblogs.com/lewis0077/p/5133812.html" target="_blank" rel="noopener">深入解析策略模式</a></p>
<blockquote>
<h2 id="二、观察者（Observer）模式"><a href="#二、观察者（Observer）模式" class="headerlink" title="二、观察者（Observer）模式"></a>二、观察者（Observer）模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><pre><code>在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。
</code></pre><h3 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h3><pre><code>其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。
</code></pre><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://upload-images.jianshu.io/upload_images/15186378-24facc73e2156842.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="01.png"></p>
<h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><ul>
<li><strong>抽象被观察者角色</strong>：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li>
<li><strong>抽象观察者角色</strong>：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li>
<li><strong>具体被观察者角色</strong>：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li>
<li><strong>具体观察者角色</strong>：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。<h3 id="使用场景例子"><a href="#使用场景例子" class="headerlink" title="使用场景例子"></a>使用场景例子</h3>有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li>
</ul>
<ol>
<li><p>定义一个抽象被观察者接口</p>
<p>/***</p>
<ul>
<li>抽象被观察者接口</li>
<li>声明了添加、删除、通知观察者方法</li>
<li><p>@author charming<br><em>
</em>/<br>public interface Observerable {</p>
<p> public void registerObserver(Observer o);<br> public void removeObserver(Observer o);<br> public void notifyObserver();</p>
</li>
</ul>
<p>}</p>
</li>
<li><p>定义一个抽象观察者接口</p>
<p>/***</p>
<ul>
<li>抽象观察者</li>
<li>定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</li>
<li>@author charming<br><em>
</em>/<br>public interface Observer {<br> public void update(String message);<br>}</li>
</ul>
</li>
<li><p>定义被观察者，实现了Observerable接口，对Observerable接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>/**</p>
<ul>
<li>被观察者，也就是微信公众号服务</li>
<li>实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</li>
<li><p>@author charming<br><em>
</em>/<br>public class WechatServer implements Observerable {</p>
<p>//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程<br>private List<observer> list;<br>private String message;</observer></p>
<p>public WechatServer() {<br>   list = new ArrayList<observer>();<br>}</observer></p>
<p>@Override<br>public void registerObserver(Observer o) {</p>
<p>   list.add(o);<br>}</p>
<p>@Override<br>public void removeObserver(Observer o) {<br>   if(!list.isEmpty())</p>
<pre><code>list.remove(o);
</code></pre><p>}</p>
<p>//遍历<br>@Override<br>public void notifyObserver() {<br>   for(int i = 0; i &lt; list.size(); i++) {</p>
<pre><code>Observer oserver = list.get(i);
oserver.update(message);
</code></pre><p>   }<br>}</p>
<p>public void setInfomation(String s) {</p>
<pre><code>this.message = s;
System.out.println(&quot;微信服务更新消息： &quot; + s);
//消息更新，通知所有观察者
notifyObserver();
</code></pre><p>}</p>
</li>
</ul>
<p>}</p>
</li>
<li><p>定义具体观察者，微信公众号的具体观察者为用户User</p>
<p>/**</p>
<ul>
<li>观察者</li>
<li>实现了update方法</li>
<li><p>@author charming<br><em>
</em>/<br>public class User implements Observer {</p>
<p> private String name;<br> private String message;</p>
<p> public User(String name) {</p>
<pre><code>this.name = name;
</code></pre><p> }</p>
<p> @Override<br>  public void update(String message) {</p>
<pre><code>this.message = message;
read();
</code></pre><p> }</p>
<p> public void read() {</p>
<pre><code>System.out.println(name + &quot; 收到推送消息： &quot; + message);
</code></pre><p> }<br>}</p>
</li>
</ul>
</li>
<li><p>编写一个测试类</p>
</li>
</ol>
<ul>
<li><p>首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。</p>
<ul>
<li>用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户<br>还是正常能收到推送消息。</li>
</ul>
<p>public class Test {<br> public static void main(String[] args) {<br>   WechatServer server = new WechatServer();</p>
</li>
</ul>
</blockquote>
<pre><code>    Observer userZhang = new User(&quot;ZhangSan&quot;);
    Observer userLi = new User(&quot;LiSi&quot;);
    Observer userWang = new User(&quot;WangWu&quot;);

    server.registerObserver(userZhang);
    server.registerObserver(userLi);
    server.registerObserver(userWang);
    server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);

    System.out.println(&quot;----------------------------------------------&quot;);
    server.removeObserver(userZhang);
    server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);   
  }
}
</code></pre><blockquote>
<p>   测试结果<br><img src="https://upload-images.jianshu.io/upload_images/15186378-638b18e87ae927d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="02.png"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>这个模式是松偶合的。改变主题或观察者中的一方，另一方不会受到影像。</li>
<li>JDK中也有自带的观察者模式。但是被观察者是一个类而不是接口，限制了它的复用能力。</li>
<li>在JavaBean和Swing中也可以看到观察者模式的影子。</li>
</ul>
</blockquote>
<blockquote>
<h2 id="三、装饰者模式"><a href="#三、装饰者模式" class="headerlink" title="三、装饰者模式"></a>三、装饰者模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    很烦，装饰者模式没保存到，由于篇幅过长我就不再贴了，放到后面与代理模式比较吧。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>   ##四、 工厂模式</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>   为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>
<h3 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h3><ul>
<li>简单工厂模式<code>Simple Factory</code>：不利于产生系列产品；</li>
<li>工厂方法模式<code>Factory Method</code>：又称为多形性工厂；</li>
<li><p>抽象工厂模式<code>Abstract Factory</code>：又称为工具箱，产生产品族，但不利于产生新的产品；</p>
<p>这三种模式从上到下逐步抽象，并且更具一般性。GOF在《设计模式》一书中将工厂模式分为两类：工厂方法模式（Factory Method）与抽象工厂模式（Abstract Factory）。将简单工厂模式（Simple Factory）看为工厂方法模式的一种特例，两者归为一类。</p>
<h4 id="1-简单工厂模式"><a href="#1-简单工厂模式" class="headerlink" title="1. 简单工厂模式"></a>1. 简单工厂模式</h4><p>简单工厂模式又称静态工厂方法模式。<br>从命名上就可以看出这个模式一定很简单。它存在的目的很简单：定义一个用于创建对象的接口。<br>在简单工厂模式中,一个工厂类处于对产品类实例化调用的中心位置上,它决定哪一个产品类应当被实例化。</p>
<p><code>先来看看它的组成：</code></p>
</li>
<li>工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。</li>
<li>抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。</li>
<li><p>具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。</p>
<p>简单工厂模式又分为三种：</p>
</li>
</ul>
<ol>
<li><p>普通:<br>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：<img src="https://upload-images.jianshu.io/upload_images/15186378-6ab84315c26a10c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="05.png"></p>
<p>举例如下：（我们举一个发送邮件和短信的例子）首先，创建二者的共同接口：</p>
</li>
</ol>
</blockquote>
<pre><code> public interface Sender {  
    public void Send();  
}
</code></pre><blockquote>
<p>   其次，创建实现类：</p>
</blockquote>
<pre><code>public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println(&quot;this is mailsender!&quot;);  
    }  
}


public class SmsSender implements Sender {  
@Override  
    public void Send() {  
        System.out.println(&quot;this is sms sender!&quot;);  
    }  
}
</code></pre><blockquote>
<p>   最后，建工厂类：</p>
</blockquote>
<pre><code>public class SendFactory {  
    public Sender produce(String type) {  
        if (&quot;mail&quot;.equals(type)) {  
            return new MailSender();  
        } else if (&quot;sms&quot;.equals(type)) {  
            return new SmsSender();  
        } else {  
            System.out.println(&quot;请输入正确的类型!&quot;);  
            return null;  
        }  
    }  
}
</code></pre><blockquote>
<p>   我们来测试下：</p>
</blockquote>
<pre><code>public class FactoryTest {  
    public static void main(String[] args) {  
        SendFactory factory = new SendFactory();  
        Sender sender = factory.produce(&quot;sms&quot;);  
        sender.Send();  
    }  
}
</code></pre><blockquote>
<p>   输出：this is sms sender!</p>
</blockquote>
<blockquote>
<ol start="2">
<li>多个方法<br>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：<img src="https://upload-images.jianshu.io/upload_images/15186378-71d5112bd1247492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="06.png"><br>将上面的代码做下修改，改动下SendFactory类就行，如下：</li>
</ol>
</blockquote>
<pre><code>public class SendFactory {  
   public Sender produceMail(){  
        return new MailSender();  
    }  

    public Sender produceSms(){  
        return new SmsSender();  
    }  
}  
</code></pre><blockquote>
<p>   测试类如下：</p>
</blockquote>
<pre><code>public class FactoryTest {  
    public static void main(String[] args) {  
        SendFactory factory = new SendFactory();  
        Sender sender = factory.produceMail();  
        sender.Send();  
    }  
}
</code></pre><blockquote>
<p>   输出：this is mailsender!</p>
</blockquote>
<blockquote>
<ol start="3">
<li>多个静态方法<br>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</li>
</ol>
</blockquote>
<pre><code>public class SendFactory {  

      public static Sender produceMail(){  
          return new MailSender();  
      }  

      public static Sender produceSms(){  
          return new SmsSender();  
      }  
}

public class FactoryTest {  

    public static void main(String[] args) {      
        Sender sender = SendFactory.produceMail();  
        sender.Send();  
    }  
}
</code></pre><blockquote>
<p>  输出：this is mailsender!</p>
</blockquote>
<blockquote>
<p>   总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p>
</blockquote>
<blockquote>
<h4 id="2-工厂方法模式（Factory-Method）"><a href="#2-工厂方法模式（Factory-Method）" class="headerlink" title="2. 工厂方法模式（Factory Method）"></a>2. 工厂方法模式（Factory Method）</h4><p>   简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。<img src="https://upload-images.jianshu.io/upload_images/15186378-0e04f84d87817486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="07.png"></p>
</blockquote>
<pre><code>public interface Sender {  
    public void Send();  
}

//两个实现类：
public class MailSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println(&quot;this is mailsender!&quot;);  
    }  
}

public class SmsSender implements Sender {  
    @Override  
    public void Send() {  
        System.out.println(&quot;this is sms sender!&quot;);  
    }  
}

//工厂接口
public interface Provider {  
    public Sender produce();  
}

//两个工厂类：
public class SendMailFactory implements Provider {  
    @Override  
    public Sender produce(){  
        return new MailSender();  
    }  
}

public class SendSmsFactory implements Provider{  
    @Override  
     public Sender produce() {  
       return new SmsSender();  
    }  
}

//测试类：
public class Test {  
    public static void main(String[] args) {  
        Provider provider = new SendMailFactory();  
        Sender sender = provider.produce();  
        sender.Send();  
    }  
}
</code></pre><blockquote>
<p>   其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p>
</blockquote>
<blockquote>
<h4 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h4><p>   为创建一组相关或者是相互依赖的对象提供一个接口，而不需要指定他们的具体实现类。<br>   <img src="https://upload-images.jianshu.io/upload_images/15186378-b2ec9f2270ec10a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="08.png"><br>   例如：<br>Q3和Q7有不同的轮胎、发动机、制动系统。虽然生产的零件不同，型号不同。但是根本上都有共同的约束，就是轮胎、发动机、制动系统。设计如下：</p>
<pre><code>1. 需要一个抽象工厂，里面有三个接口分别为生产轮胎、发动机、制动系统，抽象类
2. 需要三个抽象产品分别为轮胎、发动机、制动系统，抽象接口
3. 需要实现上面的三个抽象接口，定义出每个接口不通的对象，比如：普通轮胎和越野轮胎
4. 需要两个具体类继承自上面的抽象类，实现具体的工厂，比如：生产Q3的工厂和生产Q7的工厂
5. 在客户端new出对应的具体工厂并调用对应的生产方法
</code></pre></blockquote>
<pre><code>//1.抽象工厂
public abstract class CarFactory {
 /**
 * 生产轮胎
 * 
 * @return 轮胎
 * */
    public abstract ITire createTire();

/**
 * 生产发动机
 * 
 * @return 发动机
 * */
    public abstract IEngine createEngine();

/**
 * 生产制动系统
 * 
 * @return 制动系统
 * */
    public abstract IBrake createBrake();

}

//2.三个产品抽象接口
public interface ITire {
/**
 * 轮胎 
 */
    void tire();
}

public interface IEngine {
/**
 *发动机 
 */
    void engine();
}

public interface IBrake {
/**
 *制动系统 
 */
    void brake();
}

//3.根据抽象接口定义不同的对象
public class NormalBrake implements IBrake{
    @Override
    public void brake() {
        System.out.println(&quot;普通制动&quot;);
    }
}
public class SeniorBrake implements IBrake{
    @Override
    public void brake() {
        System.out.println(&quot;高级制动&quot;);
    }
}  //后面的定义省略。。。。。。。。。。。。。

//4.实现具体的工厂类
public class Q3Factory extends CarFactory{

    @Override
    public ITire createTire() {
        return new NormalTire();
    }

    @Override
    public IEngine createEngine() {
        return new DomesticEngine();
    }

    @Override
    public IBrake createBrake() {
        return new NormalBrake();
    }
}

//5.客户端使用
public class Client {
    public static void main(String[] args) {
        //A车厂
        CarFactory factoryQ3 = new Q3Factory();
        factoryQ3.createTire().tire();
        factoryQ3.createEngine().engine();
        factoryQ3.createBrake().brake();
    }
}

//输出
普通轮胎
国产发动机
普通制动
</code></pre><blockquote>
<h4 id="4-工厂方法模式和抽象工厂模式区别"><a href="#4-工厂方法模式和抽象工厂模式区别" class="headerlink" title="4. 工厂方法模式和抽象工厂模式区别"></a>4. 工厂方法模式和抽象工厂模式区别</h4><p>   工厂方法模式：<br>一个抽象产品类，可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类只能创建一个具体产品类的实例。</p>
<p>   抽象工厂模式：<br>多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。<br>一个抽象工厂类，可以派生出多个具体工厂类。<br>每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。   </p>
<p>   区别：<br>工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。<br>工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。<br>工厂方法创建 “一种” 产品，他的着重点在于”怎么创建”，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。<br>抽象工厂需要创建一些列产品，着重点在于”创建哪些”产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。</p>
<p>对于java来说，你能见到的大部分抽象工厂模式都是这样的：<br>—它的里面是一堆工厂方法，每个工厂方法返回某种类型的对象。</p>
<p>比如说工厂可以生产鼠标和键盘。那么抽象工厂的实现类（它的某个具体子类）的对象都可以生产鼠标和键盘，但可能工厂A生产的是罗技的键盘和鼠标，工厂B是微软的。</p>
<p>这样A和B就是工厂，对应于抽象工厂；<br>每个工厂生产的鼠标和键盘就是产品，对应于工厂方法；</p>
<p>用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从罗技换到微软。但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便（这个工厂会替你用相应的工厂方法）</p>
<p>所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线</p>
</blockquote>
<blockquote>
<h2 id="五、单例模式"><a href="#五、单例模式" class="headerlink" title="五、单例模式"></a>五、单例模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>   单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p>
<p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>   1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。<br>   2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。<br>   3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p>
<h3 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h3><p>   单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）。</p>
<p>   单例的实现主要是通过以下两个步骤：</p>
<p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；<br>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>   单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p>
<h3 id="单例模式的八种写法"><a href="#单例模式的八种写法" class="headerlink" title="单例模式的八种写法"></a>单例模式的八种写法</h3><h4 id="1、饿汉式（静态常量）-可用"><a href="#1、饿汉式（静态常量）-可用" class="headerlink" title="1、饿汉式（静态常量）[可用]"></a>1、饿汉式（静态常量）[可用]</h4><pre><code> public class Singleton {
     private final static Singleton INSTANCE = new Singleton();

     private Singleton(){}

     public static Singleton getInstance(){
          return INSTANCE;
     }
}
</code></pre><p>优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。<br>缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。</p>
<h4 id="2、饿汉式（静态代码块）-可用"><a href="#2、饿汉式（静态代码块）-可用" class="headerlink" title="2、饿汉式（静态代码块）[可用]"></a>2、饿汉式（静态代码块）[可用]</h4><pre><code>public class Singleton {

  private static Singleton instance;

  static {
      instance = new Singleton();
  }

  private Singleton() {}

  public static Singleton getInstance() {
      return instance;
  }
}
</code></pre><p>   这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p>
<p>   ####3、懒汉式(线程不安全)[不可用]<br>     public class Singleton {</p>
<pre><code>    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre><p>   这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。</p>
<p>   ####4、懒汉式(线程安全，同步方法)[不推荐用]<br>     public class Singleton {</p>
<pre><code>    private static Singleton singleton;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
</code></pre><p>   解决上面第三种实现方式的线程不安全问题，做个线程同步就可以了，于是就对getInstance()方法进行了线程同步。</p>
<p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p>
<p>   ####5、懒汉式(线程安全，同步代码块)[不可用]<br>     public class Singleton {</p>
<pre><code>    private static Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}
</code></pre><p>   由于第四种实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。</p>
<p>   ####6、双重检查[推荐用]<br>     public class Singleton {</p>
<pre><code>    private static volatile Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
</code></pre><p>Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。</p>
<p>优点：线程安全；延迟加载；效率较高。</p>
<p>   ####7、静态内部类[推荐用]<br>     public class Singleton {</p>
<pre><code>    private Singleton() {}

    private static class SingletonInstance {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
</code></pre><p>   这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。</p>
<p>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p>
<p>优点：避免了线程不安全，延迟加载，效率高。</p>
<p>   ####8、枚举[推荐用]<br>     public enum Singleton {<br>         INSTANCE;<br>         public void whateverMethod() {</p>
<pre><code>    }
}
</code></pre><p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>   1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p>
<p>   2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p>
<p>   采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？</p>
<p>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）</p>
<p>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p>
<p>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。</p>
<p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。</p>
</blockquote>
<p><code>参考自</code><a href="https://www.cnblogs.com/zhaoyan001/p/6365064.html" target="_blank" rel="noopener">单例模式的八种写法比较</a></p>
<blockquote>
<p>   ##六、命令模式</p>
<h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>   命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。<br>Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>   假设某个公司需要设计一个多用功能的遥控器。基本的需求如下：</p>
<p>该遥控器有可以控制风扇，白炽灯，热水器等等的多对开关，而且可能还有其他的电器，暂时不做其功能，但是希望可以保留接口，用的时间可以方便的扩展。</p>
<p>除上面的需求之外，还需要有个按钮，可以撤销上一步的操作。基本功能如下图：<br><img src="https://upload-images.jianshu.io/upload_images/15186378-220186ae6b4dc0d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="09.png"><br>在设计遥控器时，风扇，白炽灯，热水器的开关方法已经定义好，其名字各不相同。不妨设置其方法为如下：<br><img src="https://upload-images.jianshu.io/upload_images/15186378-c326841dacc95659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.png"></p>
<p>由于各种电器的开关方法都不一样，而且还存在一个待扩展的电器，如果没有学习命名模式之前，我们在设置扩展的开关时，会出现的问题是什么呢？假设现在有电视，冰箱还可能会用到遥控器，那么我们会在最后一个开关上写if else，当然如果哪一天有多了一个大门也加入了我们的遥控的行列，这样我们继续加if else ，很显然随着电器的高速发展，会有多个需要遥控可以控制的。</p>
<p>举个例子，如果我们是需要遥控的客户，现在有一款遥控如果有遥控可以进行扩展，一种是可以扩展指定类型的，像上面的，只能再去扩展电视和冰箱中的一种，偶尔有一天你看到隔壁邻居的门，也可以使用遥控了，所以你去把你的高级遥控器，拿到扩展店时，扩展工程师说了，现在只能扩展电视和冰箱，不支持对大门的遥控扩展.</p>
<p>我们肯定是希望，可以自由的扩展，大门可以使用遥控了，就对大门扩展，车门使用遥控了，就对车门扩展……其实也就是一种松耦合的实现。</p>
<p>我们可以先定义好我们的风扇，白炽灯，热水器。然后定义其分别的开关命令，每个命令都有自己对应的电器引用，而且会在命令的Excute中包装电器的开或者关，最后需要把命令安装到遥控器上面，在遥控器上每个按钮都对应有自己的激发方法，其代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">namespace RemoteControl</span><br><span class="line">&#123;</span><br><span class="line">    class Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //家中的电器</span><br><span class="line">            Fan fan=new Fan();</span><br><span class="line">            Light light=new Light();</span><br><span class="line">            Heater heater=new Heater();</span><br><span class="line"></span><br><span class="line">            //电器分别对应的命令</span><br><span class="line">            FanOffCommand fanOffCommand=new FanOffCommand(fan);</span><br><span class="line">            FanOnCommand fanOnCommand=new FanOnCommand(fan);</span><br><span class="line">            LightOnCommand lightOnCommand=new LightOnCommand(light);</span><br><span class="line">            LightOffCommand lightOffCommand=new LightOffCommand(light);</span><br><span class="line">            HeaterOnCommand heaterOnCommand=new HeaterOnCommand(heater);</span><br><span class="line">            HeaterOffCommand heaterOffCommand=new HeaterOffCommand(heater);</span><br><span class="line">            RemoteControl remoteControl = new RemoteControl();</span><br><span class="line"></span><br><span class="line">            //设置遥控器</span><br><span class="line">            remoteControl.SetCommand(0, fanOnCommand, fanOffCommand);</span><br><span class="line">            remoteControl.SetCommand(1, lightOnCommand, lightOffCommand);</span><br><span class="line">            remoteControl.SetCommand(2, heaterOnCommand, heaterOffCommand);</span><br><span class="line">            //分别测试遥控器的命令</span><br><span class="line">            remoteControl.OnButtonWasPress(1);</span><br><span class="line">            remoteControl.OffButtonWasPress(1);</span><br><span class="line">            remoteControl.OnButtonWasPress(0);</span><br><span class="line">            remoteControl.OffButtonWasPress(0);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 风扇类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">   public class Fan</span><br><span class="line">    &#123;</span><br><span class="line">        public void FanOn()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;风扇开了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public void FanOff()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;风扇关了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 灯类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">   public class Light</span><br><span class="line">   &#123;</span><br><span class="line">       public void LightOn()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;灯亮了&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public void LightOff()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;灯灭了&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 热水器类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">   public class Heater</span><br><span class="line">   &#123;</span><br><span class="line">       public void HeaterOn()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;加热中&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       public void HeaterOff()</span><br><span class="line">       &#123;</span><br><span class="line">           Console.WriteLine(&quot;停止加热&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 命令接口</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">   public interface ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       void Excute();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class FanOnCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       Fan fan;</span><br><span class="line">       public FanOnCommand(Fan fan)</span><br><span class="line">       &#123;</span><br><span class="line">           this.fan = fan;</span><br><span class="line">       &#125;</span><br><span class="line">        public void Excute()</span><br><span class="line">        &#123;</span><br><span class="line">            this.fan.FanOn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public class FanOffCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       Fan fan;</span><br><span class="line">       public FanOffCommand(Fan fan)</span><br><span class="line">       &#123;</span><br><span class="line">           this.fan = fan;</span><br><span class="line">       &#125;</span><br><span class="line">        public void Excute()</span><br><span class="line">        &#123;</span><br><span class="line">            this.fan.FanOff();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class LightOnCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       Light light;</span><br><span class="line">       public LightOnCommand(Light light)</span><br><span class="line">       &#123;</span><br><span class="line">           this.light = light; </span><br><span class="line">       &#125;</span><br><span class="line">       public void Excute()</span><br><span class="line">       &#123;</span><br><span class="line">           light.LightOn();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class LightOffCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       Light light;</span><br><span class="line">       public LightOffCommand(Light light)</span><br><span class="line">       &#123;</span><br><span class="line">           this.light = light;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Excute()</span><br><span class="line">       &#123;</span><br><span class="line">           this.light.LightOff();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class HeaterOnCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       Heater heater;</span><br><span class="line">       public HeaterOnCommand(Heater heater)</span><br><span class="line">       &#123;</span><br><span class="line">           this.heater = heater;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Excute()</span><br><span class="line">       &#123;</span><br><span class="line">           this.heater.HeaterOn();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class HeaterOffCommand : ICommand</span><br><span class="line">   &#123; </span><br><span class="line">       Heater heater;</span><br><span class="line">       public HeaterOffCommand(Heater heater)</span><br><span class="line">       &#123;</span><br><span class="line">           this.heater = heater;</span><br><span class="line">       &#125;</span><br><span class="line">       public void Excute()</span><br><span class="line">       &#123;</span><br><span class="line">           this.heater.HeaterOff();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class NoCommand : ICommand</span><br><span class="line">   &#123;</span><br><span class="line">       public void Excute()</span><br><span class="line">       &#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public class RemoteControl</span><br><span class="line">   &#123;</span><br><span class="line">      private ICommand[] onCommands;</span><br><span class="line">      private ICommand[] offCommands;</span><br><span class="line">      public RemoteControl()</span><br><span class="line">      &#123;</span><br><span class="line">         ICommand noCommand=new NoCommand();</span><br><span class="line">          onCommands = new ICommand[4];</span><br><span class="line">          offCommands = new ICommand[4];</span><br><span class="line">          for (int i = 0; i &lt; 4; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              onCommands[i] = noCommand;</span><br><span class="line">              offCommands[i] = noCommand;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void SetCommand(int slot, ICommand onCommand, ICommand offCommand)</span><br><span class="line">      &#123;</span><br><span class="line">          onCommands[slot] = onCommand;</span><br><span class="line">          offCommands[slot] = offCommand;</span><br><span class="line">      &#125;</span><br><span class="line">      public void OnButtonWasPress(int slot)</span><br><span class="line">      &#123;</span><br><span class="line">          onCommands[slot].Excute();</span><br><span class="line">      &#125;</span><br><span class="line">      public void OffButtonWasPress(int slot)</span><br><span class="line">      &#123;</span><br><span class="line">          offCommands[slot].Excute();</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这样基本上就实现了我们的现有的三种电器的遥控。需要注意的是，在开始初始化遥控器时，对每个命令初始化成了NoCommand，也就是什么都不执行。在命令的初始化经常使用，同时这也解决了我们的在扩展前什么都不做的难题。看了风扇，白炽灯，热水器的遥控实现，进一步的扩展任何的电器，相信都不是什么难事。但是还有个功能没有实现，就是撤销到上一步的操作，接下来我们就来实现撤销操作。</p>
<p>撤销操作就想我们遥控中的返回一样。基本上就是灯亮着，突然按了一下关灯，然后再按一下返回键，灯就亮了。其他的电器同样的道理。下面先看一下灯的撤销原理，命令除了执行外还有一个撤销，所以我们需要先都命令的接口添加一个方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt; </span><br><span class="line">/// 命令接口 </span><br><span class="line">/// &lt;/summary&gt; </span><br><span class="line">public interface ICommand </span><br><span class="line">&#123; </span><br><span class="line">    void Excute(); </span><br><span class="line">    void Undo(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">对于开灯需要做的修改如下：</span><br><span class="line"></span><br><span class="line">public class LightOnCommand : ICommand </span><br><span class="line">   &#123; </span><br><span class="line">       Light light; </span><br><span class="line">       public LightOnCommand(Light light) </span><br><span class="line">       &#123; </span><br><span class="line">           this.light = light; </span><br><span class="line">       &#125; </span><br><span class="line">       public void Excute() </span><br><span class="line">       &#123; </span><br><span class="line">           light.LightOn(); </span><br><span class="line">       &#125; </span><br><span class="line">       /// &lt;summary&gt; </span><br><span class="line">       /// 调用命令的反命令 </span><br><span class="line">       /// &lt;/summary&gt; </span><br><span class="line">       public void Undo() </span><br><span class="line">       &#123; </span><br><span class="line">           light.LightOff(); </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他命令同理，代码会在源码中一并给出。也就是每个命令都有自己的反命令，在Undo方法里面也就是调用反命令的Excute方法。每当按下一个按钮时，就去记录其命令的名称，如果按撤销的话，就执行命名的Undo方法。下面给出主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void OnButtonWasPressed(int slot) </span><br><span class="line">   &#123; </span><br><span class="line">       onCommands[slot].Excute(); </span><br><span class="line">       backCommand=onCommands[slot]; </span><br><span class="line">   &#125; </span><br><span class="line">   public void OffButtonWasPressed(int slot) </span><br><span class="line">   &#123; </span><br><span class="line">       offCommands[slot].Excute(); </span><br><span class="line">       backCommand = offCommands[slot]; </span><br><span class="line">   &#125; </span><br><span class="line">   public void BackButtonWasPressed() </span><br><span class="line">   &#123; </span><br><span class="line">       backCommand.Undo(); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>以上是对遥控器对命令的撤销，需要注意两点1、通过记住命令执行之前的状态，然后去恢复到原来的状态。2、在每次执行之后要记住执行的那个命令。也即记住命令和记住状态。</p>
<p>除了一次执行一个命令和撤销一个命令，当然还可以一次执行多个命令。下面给出主要代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MutlipleCommand : ICommand </span><br><span class="line">   &#123; </span><br><span class="line">       ICommand[] commands; </span><br><span class="line">       ICommand[] backCommands; </span><br><span class="line">       public MutlipleCommand(ICommand[] commands) </span><br><span class="line">       &#123; </span><br><span class="line">           this.commands = commands; </span><br><span class="line">           backCommands = new ICommand[commands.Length]; </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       public void Excute() </span><br><span class="line">       &#123; </span><br><span class="line">           for (int i = 0; i &lt; commands.Length; i++) </span><br><span class="line">            &#123; </span><br><span class="line">              commands[i].Excute(); </span><br><span class="line">              backCommands[i] = commands[i]; </span><br><span class="line">            &#125; </span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public void Undo() </span><br><span class="line">       &#123; </span><br><span class="line">           for (int i = 0; i &lt; commands.Length; i++) </span><br><span class="line">           &#123; </span><br><span class="line">               backCommands[i].Undo(); </span><br><span class="line">           &#125; </span><br><span class="line">       &#125; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://upload-images.jianshu.io/upload_images/15186378-a0e6f65dee69dbb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p>
<p>命令模式主要通过中介Command实现了发出命令者和命令的执行者，也即Invoke类和Receiver的松耦合。</p>
</blockquote>
<p><code>参考自</code><a href="https://www.cnblogs.com/lzhp/p/3395320.html" target="_blank" rel="noopener">命令模式</a></p>
<blockquote>
<h2 id="七、适配器模式"><a href="#七、适配器模式" class="headerlink" title="七、适配器模式"></a>七、适配器模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>   适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。</p>
<p>   ###1、类的适配器模式<br><img src="https://upload-images.jianshu.io/upload_images/15186378-78d18cfbf5916496.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.png"></p>
<p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口是Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class Source &#123;  </span><br><span class="line">  </span><br><span class="line">    public void method1() &#123;  </span><br><span class="line">        System.out.println(&quot;this is original method!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Targetable &#123;  </span><br><span class="line">  </span><br><span class="line">    /* 与原类中的方法相同 */  </span><br><span class="line">    public void method1();  </span><br><span class="line">  </span><br><span class="line">    /* 新类的方法 */  </span><br><span class="line">    public void method2();  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class Adapter extends Source implements Targetable &#123;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void method2() &#123;  </span><br><span class="line">        System.out.println(&quot;this is the targetable method!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Adapter类继承Source类，实现Targetable接口，下面是测试类：</span><br><span class="line">public class AdapterTest &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Targetable target = new Adapter();  </span><br><span class="line">        target.method1();  </span><br><span class="line">        target.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">this is original method!</span><br><span class="line">this is the targetable method!</span><br><span class="line"></span><br><span class="line">这样Targetable接口的实现类就具有了Source类的功能。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>   ###2、对象的适配器模式<br>   基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：<br>   <img src="https://upload-images.jianshu.io/upload_images/15186378-c0787ee2f92f390e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="13.png"><br>   只需要修改Adapter类的源码即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Wrapper implements Targetable &#123;  </span><br><span class="line">  </span><br><span class="line">    private Source source;  </span><br><span class="line">      </span><br><span class="line">    public Wrapper(Source source)&#123;  </span><br><span class="line">        super();  </span><br><span class="line">        this.source = source;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void method2() &#123;  </span><br><span class="line">        System.out.println(&quot;this is the targetable method!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void method1() &#123;  </span><br><span class="line">        source.method1();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AdapterTest &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Source source = new Source();  </span><br><span class="line">        Targetable target = new Wrapper(source);  </span><br><span class="line">        target.method1();  </span><br><span class="line">        target.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line">输出与第一种一样，只是适配的方法不同而已。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>   ###3、接口的适配器模式<br>   第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：<br><img src="https://upload-images.jianshu.io/upload_images/15186378-2b7e4d504c0dd60b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="14.png"><br>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public interface Sourceable &#123;  </span><br><span class="line">      </span><br><span class="line">    public void method1();  </span><br><span class="line">    public void method2();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Wrapper2 implements Sourceable&#123;  </span><br><span class="line">      </span><br><span class="line">    public void method1()&#123;&#125;  ;</span><br><span class="line">    public void method2()&#123;&#125;  ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SourceSub1 extends Wrapper2 &#123;  </span><br><span class="line">    public void method1()&#123;  </span><br><span class="line">        System.out.println(&quot;the sourceable interface&apos;s first Sub1!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SourceSub2 extends Wrapper2 &#123;  </span><br><span class="line">    public void method2()&#123;  </span><br><span class="line">        System.out.println(&quot;the sourceable interface&apos;s second Sub2!&quot;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WrapperTest &#123;  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) &#123;  </span><br><span class="line">        Sourceable source1 = new SourceSub1();  </span><br><span class="line">        Sourceable source2 = new SourceSub2();  </span><br><span class="line">          </span><br><span class="line">        source1.method1();  </span><br><span class="line">        source1.method2();  </span><br><span class="line">        source2.method1();  </span><br><span class="line">        source2.method2();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>测试输出：</p>
<p>the sourceable interface’s first Sub1!<br>the sourceable interface’s second Sub2!</p>
<p>达到了我们的效果！</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>   类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p>
<p>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p>
<p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p>
</blockquote>
<blockquote>
<h2 id="八、模板方法模式（略）"><a href="#八、模板方法模式（略）" class="headerlink" title="八、模板方法模式（略）"></a>八、模板方法模式（略）</h2></blockquote>
<blockquote>
<h2 id="九、迭代器与组合模式（略）"><a href="#九、迭代器与组合模式（略）" class="headerlink" title="九、迭代器与组合模式（略）"></a>九、迭代器与组合模式（略）</h2></blockquote>
<blockquote>
<h2 id="十、状态模式（略）"><a href="#十、状态模式（略）" class="headerlink" title="十、状态模式（略）"></a>十、状态模式（略）</h2></blockquote>
<blockquote>
<h2 id="十一、代理模式（极其重要）"><a href="#十一、代理模式（极其重要）" class="headerlink" title="十一、代理模式（极其重要）"></a>十一、代理模式（极其重要）</h2><h3 id="与装饰者模式的区别"><a href="#与装饰者模式的区别" class="headerlink" title="与装饰者模式的区别"></a>与装饰者模式的区别</h3><p>   装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>   例如：有婴儿，婴儿会吃饭和走动，如以下类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//婴儿类</span><br><span class="line">public class Child implements Human</span><br><span class="line">&#123;</span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;eat something....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Child run very slow&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>突然有一天，家长发现不行，孩子不能随便吃东西，而且吃饭前一定要洗手。但是孩子太小(被委托方)，不会自己洗手。家长(Client 端)又没法照顾孩子。那简单，找个保姆照顾孩子！ 让保姆类和婴儿类共同实现同一个接口，让保姆类全程管理小孩，同时在家长眼里，只要看到保姆在帮孩子洗手就可以了。于是，有以下内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//保姆类</span><br><span class="line">public class BabySitter implements Human</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>现在保姆已经有了，孩子也有了，怎么把孩子跟保姆关联起来。让保姆给相应的孩纸洗手。于是保姆类更改如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//保姆类</span><br><span class="line">public class BabySitter implements Human</span><br><span class="line">&#123;</span><br><span class="line">    private Human human;</span><br><span class="line"></span><br><span class="line">    public BabySitter(Human human)</span><br><span class="line">    &#123;</span><br><span class="line">        this.human = human;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        // 添加washHand的方法</span><br><span class="line">        this.washHandForChild();</span><br><span class="line">        human.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void washHandForChild()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;help the child to wash his hands&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">保姆与婴儿类关联</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>好，那么家长就是给孩纸找了个保姆助手(装饰器)，让他附加了一些婴儿做不了事。同时家长也没有强迫孩纸自己学会洗手(不更改Child类)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//客户端</span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Human human = new BabySitter(new Child());</span><br><span class="line">        human.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">家长客户端代码</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>  以上就是一个简单的装饰模式，来看一下这一块完整的类图。<br><img src="https://upload-images.jianshu.io/upload_images/15186378-b0de8a7a3a35d3c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="15.png"><br>     装饰模式的一个很重要特点就是，在客户端可以看到抽象对象的实例，如Human human = new BabySitter(new Child()); 因为装饰模式通过聚合方式，把内容整合到装饰类里面了。</p>
<p>　   装饰者模式能够使用装饰类对抽象对象进行装饰。假如来了个OldMan类手脚不利索。保姆类BabySitter同样能够胜任这个OldMan的饭前洗手操作。</p>
<blockquote>
<p>代理模式类图如下：</p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/15186378-41d76477cb36be59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="16.png"><br>由该类图可知，以上BabySitter代码应该如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//保姆类</span><br><span class="line">public class BabySitter implements Human</span><br><span class="line">&#123;    </span><br><span class="line">    private Child child;</span><br><span class="line"></span><br><span class="line">    public BabySitter()</span><br><span class="line">    &#123;</span><br><span class="line">        child = new Child();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void eat()</span><br><span class="line">    &#123;</span><br><span class="line">        // 添加washHand的方法</span><br><span class="line">        this.washHandForChild();</span><br><span class="line">        human.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void washHandForChild()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;help the child to wash his hands&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//客户端</span><br><span class="line">public class Client</span><br><span class="line">&#123;</span><br><span class="line">    public static void main(String[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Human human = new BabySitter();</span><br><span class="line">        human.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>装饰者模式和代理模式的最后运行的结果都是一样的，由代理模式代码可知，客户端不关心代理类了哪个类。但代码控制了客户端对委托类的访问。客户端代码表现为 Human human = new BabySitter( );</p>
<p>所以资料上都说了，装饰模式主要是强调对类中代码的拓展，而代理模式则偏向于委托类的访问限制。两者都一样拥有抽象角色（接口）、真实角色（委托类）、代理类 。</p>
<p>由于代理类实现了抽象角色的接口，导致代理类无法通用。如有天，一个有钱人养了只小猩猩，他要一个保姆在猩猩吃东西前，帮猩猩洗手….保姆根本不懂猩猩的特性（跟猩猩类不是同一类型的，保姆属于Human类，而猩猩可能属于Animal类型。），但洗手这个方法是不变的，用水洗。能不能找一个代理说既可以照看人吃饭前洗手也可以照看猩猩吃饭前洗手？</p>
<p>要实现这种功能，必须让代理类与特定的接口分离。在代理的时候能够了解每个委托的特性，这就有可能了。这时候动态代理就出现了。</p>
<p>   <strong><em>动态代理</em></strong><br>关于动态代理模式里面有两种实现，一种是jdk实现，一种是cglib来实现。<br>下面来整jdk来实现动态代理的Java实例。<br>jdk动态代理模式里面有个拦截器的概念，在jdk中，只要实现了InvocationHandler这个接口的类就是一个拦截器类。<br>还使用了些反射的相关概念。<br>拦截器的概念不了解没关系，假如写了个请求到action，经过拦截器，然后才会到action。然后继续有之后的操作。<br>拦截器就像一个过滤网，一层层的过滤，只要满足一定条件，才能继续向后执行。<br>拦截器的作用：控制目标对象的目标方法的执行。</p>
<p>拦截器的具体操作步骤：<br>1.引入类：目标类和一些扩展方法相关的类。<br>2.赋值：调用构造函数给相关对象赋值<br>3.合并逻辑处理：在invoke方法中把所有的逻辑结合在一起。最终决定目标方法是否被调用。</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>   动态代理静态代理的区别，代理涉及到两个关联词代理类和委托类。静态代理一个代理类针对一个委托类！动态代理一个代理类可利用反射机制代理多个委托类</p>
<p>我们根据加载被代理类的时机不同，将代理分为静态代理和动态代理。如果我们在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类这就是动态代理，比如RPC框架和Spring AOP机制。</p>
</blockquote>
<p><code>参考自</code><a href="https://www.cnblogs.com/doucheyard/p/5737366.html" target="_blank" rel="noopener">代理模式和装饰模式</a></p>

      
    </div>

    

    
    
    
<div>
  
    <div>
    
        <div style="text-align:center;color: #EC0C1C;font-size:21px;">======  END <i class="fa fa-heart"></i> THANKS  ======</div>
    
</div>
  
</div>
<div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2019/05/22/浅谈设计模式/">浅谈设计模式</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 CuiHongMing 的个人博客">CuiHongMing</a></p>
  <p><span>发布时间:</span>2019年05月22日 - 09:05</p>
  <p><span>最后更新:</span>2019年05月22日 - 09:05</p>
  <p><span>原始链接:</span><a href="/2019/05/22/浅谈设计模式/" title="浅谈设计模式">https://charming-victim.github.io/2019/05/22/浅谈设计模式/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://charming-victim.github.io/2019/05/22/浅谈设计模式/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> 转载请保留原文链接及作者。</p>
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>


      
</div>
    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>如果本文对你有所帮助，请点击下面按钮——1元就足够感动我：)</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.jpeg" alt="CuiHongMing WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/thankyou.jpeg" alt="CuiHongMing ☜ 微信 or 支付宝 ☞">
        <p>☜ 微信 or 支付宝 ☞</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.jpg" alt="CuiHongMing Alipay">
        <p>Alipay</p>
      </div>
    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/设计模式/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/16/计算机网络知识巩固-十三/" rel="next" title="计算机网络知识巩固(十三)">
                <i class="fa fa-chevron-left"></i> 计算机网络知识巩固(十三)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/12/软件过程管理复习攻略/" rel="prev" title="软件过程管理复习攻略">
                软件过程管理复习攻略 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80MzYxMi8yMDE1MQ"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/kobe.jpeg" alt="CuiHongMing">
            
              <p class="site-author-name" itemprop="name">CuiHongMing</p>
              <div class="site-description motion-element" itemprop="description">爱好运动的码农</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/Charming-Victim" title="GitHub &rarr; https://github.com/Charming-Victim" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/charmingchm" title="Weibo &rarr; https://weibo.com/charmingchm" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.niracler.com/" title="https://www.niracler.com/" rel="noopener" target="_blank">niracler的博客</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          

          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式分类"><span class="nav-number">1.</span> <span class="nav-text">设计模式分类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#设计模式六大原则"><span class="nav-number">2.</span> <span class="nav-text">设计模式六大原则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总原则：开闭原则（Open-Close-Principle）"><span class="nav-number">2.1.</span> <span class="nav-text">总原则：开闭原则（Open Close Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1、单一职责原则"><span class="nav-number">2.2.</span> <span class="nav-text">1、单一职责原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、里氏替换原则（Liskov-Substitution-Principle）"><span class="nav-number">2.3.</span> <span class="nav-text">2、里氏替换原则（Liskov Substitution Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、依赖倒转原则（Dependence-Inversion-Principle）"><span class="nav-number">2.4.</span> <span class="nav-text">3、依赖倒转原则（Dependence Inversion Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、接口隔离原则（Interface-Segregation-Principle）"><span class="nav-number">2.5.</span> <span class="nav-text">4、接口隔离原则（Interface Segregation Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、迪米特法则（最少知道原则）（Demeter-Principle）"><span class="nav-number">2.6.</span> <span class="nav-text">5、迪米特法则（最少知道原则）（Demeter Principle）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、合成复用原则（Composite-Reuse-Principle）"><span class="nav-number">2.7.</span> <span class="nav-text">6、合成复用原则（Composite Reuse Principle）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java的设计模式"><span class="nav-number">3.</span> <span class="nav-text">Java的设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、策略模式"><span class="nav-number">3.1.</span> <span class="nav-text">一、策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义"><span class="nav-number">3.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">3.1.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例"><span class="nav-number">3.1.3.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组成"><span class="nav-number">3.1.4.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写步骤"><span class="nav-number">3.1.5.</span> <span class="nav-text">编写步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例"><span class="nav-number">3.1.6.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">3.1.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、观察者（Observer）模式"><span class="nav-number">3.2.</span> <span class="nav-text">二、观察者（Observer）模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大白话"><span class="nav-number">3.2.2.</span> <span class="nav-text">大白话</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构图"><span class="nav-number">3.2.3.</span> <span class="nav-text">结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组成-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景例子"><span class="nav-number">3.2.5.</span> <span class="nav-text">使用场景例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现"><span class="nav-number">3.2.6.</span> <span class="nav-text">具体实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">3.2.7.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、装饰者模式"><span class="nav-number">3.3.</span> <span class="nav-text">三、装饰者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">3.3.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类别"><span class="nav-number">3.3.2.</span> <span class="nav-text">类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-简单工厂模式"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">1. 简单工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-工厂方法模式（Factory-Method）"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">2. 工厂方法模式（Factory Method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-抽象工厂模式"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">3. 抽象工厂模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-工厂方法模式和抽象工厂模式区别"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">4. 工厂方法模式和抽象工厂模式区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、单例模式"><span class="nav-number">3.4.</span> <span class="nav-text">五、单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-2"><span class="nav-number">3.4.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#好处"><span class="nav-number">3.4.2.</span> <span class="nav-text">好处</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的实现思路"><span class="nav-number">3.4.3.</span> <span class="nav-text">基本的实现思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注意事项"><span class="nav-number">3.4.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例模式的八种写法"><span class="nav-number">3.4.5.</span> <span class="nav-text">单例模式的八种写法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、饿汉式（静态常量）-可用"><span class="nav-number">3.4.5.1.</span> <span class="nav-text">1、饿汉式（静态常量）[可用]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、饿汉式（静态代码块）-可用"><span class="nav-number">3.4.5.2.</span> <span class="nav-text">2、饿汉式（静态代码块）[可用]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">3.4.6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-3"><span class="nav-number">3.4.7.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例-1"><span class="nav-number">3.4.8.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-2"><span class="nav-number">3.4.9.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、适配器模式"><span class="nav-number">3.5.</span> <span class="nav-text">七、适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义-4"><span class="nav-number">3.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-3"><span class="nav-number">3.5.2.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、模板方法模式（略）"><span class="nav-number">3.6.</span> <span class="nav-text">八、模板方法模式（略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、迭代器与组合模式（略）"><span class="nav-number">3.7.</span> <span class="nav-text">九、迭代器与组合模式（略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、状态模式（略）"><span class="nav-number">3.8.</span> <span class="nav-text">十、状态模式（略）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十一、代理模式（极其重要）"><span class="nav-number">3.9.</span> <span class="nav-text">十一、代理模式（极其重要）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#与装饰者模式的区别"><span class="nav-number">3.9.1.</span> <span class="nav-text">与装饰者模式的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举个例子"><span class="nav-number">3.9.2.</span> <span class="nav-text">举个例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-4"><span class="nav-number">3.9.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CuiHongMing</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Symbols count total: </span>
    
    <span title="Symbols count total">64k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    
    <span title="Reading time total">59 mins.</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/affix.js?v=7.1.0"></script>

  <script src="/js/schemes/pisces.js?v=7.1.0"></script>



  
  <script src="/js/scrollspy.js?v=7.1.0"></script>
<script src="/js/post-details.js?v=7.1.0"></script>



  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  


  
    <script>
  window.livereOptions = {
    refer: '2019/05/22/浅谈设计模式/'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
<script>
if ($('body').find('div.pdf').length) {
  $.ajax({
    type: 'GET',
    url: '//cdn.jsdelivr.net/npm/pdfobject@2.1.1/pdfobject.min.js',
    dataType: 'script',
    cache: true,
    success: function() {
      $('body').find('div.pdf').each(function(i, o) {
        PDFObject.embed($(o).attr('target'), $(o), {
          pdfOpenParams: {
            navpanes: 0,
            toolbar: 0,
            statusbar: 0,
            pagemode: 'thumbs',
            view: 'FitH'
          },
          PDFJS_URL: '/lib/pdf/web/viewer.html',
          height: $(o).attr('height') || '500px'
        });
      });
    },
  });
}
</script>


  

  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>


  

  

  

  

  

  

  

  

<script src="/node_modules/hexo-helper-live2d/"></script><script>L2Dwidget.init({"model":{"jsonPath":"live2d-widget-model-miku"},"display":{"position":"right","width":140,"height":260},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
<!-- 百度爬虫 -->
<script type="text/javascript" src="/js/bai.js"></script>
